<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从一个耳熟能详的公式了解5G网络]]></title>
    <url>%2F2018%2F12%2F18%2F%E4%BB%8E%E4%B8%80%E4%B8%AA%E8%80%B3%E7%86%9F%E8%83%BD%E8%AF%A6%E7%9A%84%E5%85%AC%E5%BC%8F%E4%BA%86%E8%A7%A35G%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[一个简单且神奇物理学公式光速=波长×频率。 对于这个公式，可以这么说：无论是1G、2G、3G，4G还是5G网络，万变不离其宗，全部都是围绕它来做文章的。 有线通信&amp;无线通信通信技术，归根到底，就分为两种——有线通信和无线通信。 我和你打电话，信息数据要么在空中传播（看不见、摸不着），要么在实物上传播（看得见、摸得着）。 即如果是在实体物质上传播，就是有线通信，基本上就是用的铜线、光纤这些线缆，统称为有线介质。 有线通信在有线介质上传播数据，速率可以达到很高的数值。 以光纤为例，在实验室中，单条光纤最大速度已达到了26Tbps…是传统网线的两万六千倍… 而空中传播这部分，才是移动通信的瓶颈所在。 无线通信目前主流的移动通信标准，是4G LTE，理论速率只有150Mbps（不包括载波聚合）。这个和有线通信是完全没办法相比的。所以，5G如果要实现端到端的高速率，重点是突破无线这部分的瓶颈。 无线通信就是利用电磁波进行通信。 电波和光波，都属于电磁波。 电磁波的功能特性，是由它的频率决定的。不同频率的电磁波，有不同的属性特点，从而有不同的用途。 例如，高频的γ射线，具有很大的杀伤力，可以用来治疗肿瘤。 我们目前主要使用电波进行通信。当然，光波通信也在崛起，例如LiFi。 电波电波属于电磁波的一种，它的频率资源是有限的。大家都在使用电波，那么，为了避免干扰和冲突，就必须进行“划分”。 好比一条高速公路上一个方向有四个个车道。从左侧数，一般的限速规定如下：第一条车道：100-120公里/小时(一般为小客车专用);第二条车道：80-100公里/小时;第三条车道：60-100公里/小时;第四条车道：紧急行车道。 我们在电波这条公路上进一步划分车道，分配给不同的对象和用途。 段号频段名称频段范围 （含上限，不含下限波段名称波长范围 （含上限，不含下限）1极低频(ELF)3～30赫（Hz）极长波100～10兆米2超低频(SLF)30～300赫（Hz）超长波10～1兆米3特低频(ULF)300～3000赫（Hz）特长波100～10万米4甚低频（VLF）3～30千赫（KHz）甚长波10～1万米5低频（LF）30～300千赫（KHz）长波10～1千米6中频（MF）300～3000千赫（KHz）中波10～1百米7高频（HF）3～30兆赫（MHz）短波100～10米8甚高频（VHF）30～300兆赫（MHz）超短波10～1米9特高频（UHF）300～3000兆赫（MHz）分米波微波10～1分米10超高频（SHF）3～30吉赫（GHz）厘米波10～1厘米11极高频（EHF）30～300吉赫（GHz）毫米波10～1毫米12至高频300～3000吉赫（GHz）丝米波10～1丝米 一直以来，我们主要是用中频~超高频进行手机通信的。 例如经常说的“GSM900”、“CDMA800”，其实意思就是指，工作频段在900MHz的GSM，和工作频段在800MHz的CDMA。 目前全球主流的4G LTE技术标准，属于特高频和超高频。我们国家主要使用超高频.随着1G、2G、3G、4G的发展，使用的电波频率是越来越高的。 这是为什么呢？ 更高的频率→更多的资源→更快的速度这主要是因为，频率越高，能使用的频率资源越丰富。频率资源越丰富，能实现的传输速率就越高。 频率资源就像车厢，越高的频率，车厢越多，相同时间内能装载的信息就越多。 那么，5G使用的频率具体是多少呢？ 5G的频率范围，分为两种：一种是6GHz以下，这个和目前我们的2/3/4G差别不算太大。还有一种，就很高了，在24GHz以上。 目前，国际上主要使用28GHz进行试验（这个频段也有可能成为5G最先商用的频段）。 为什么以前我们不用高频率呢？这个就是5G的第一个技术特点——毫米波。 问题的原因很简单——不是不想用，是用不起！ 电磁波的显著特点：频率越高，波长越短，越趋近于直线传播（绕射能力越差）。频率越高，在传播介质中的衰减也越大。 例如： 激光笔（波长635nm左右），射出的光是直的吧，挡住了就过不去了。 再看卫星通信和GPS导航（波长1cm左右），如果有遮挡物，就没信号了。 卫星那口大锅，必须校准瞄着卫星的方向，否则哪怕稍微歪一点，都会影响信号质量。 移动通信如果用了高频段，那么它最大的问题，就是传输距离大幅缩短，覆盖能力大幅减弱。 覆盖同一个区域，需要的5G基站数量，将大大超过4G。 基站数量意味着什么？钱啊！投资啊！成本啊！ 频率越低，网络建设就越省钱，竞争起来就越有利。这就是为什么，这些年，电信、移动、联通为了低频段而争得头破血流。 有的频段甚至被称为——黄金频段。 这也是为什么，5G时代，运营商拼命怼设备商，希望基站降价。（如果真的上5G，按以往的模式，设备商就发大财了。） 所以，基于以上原因，在高频率的前提下，为了减轻网络建设方面的成本压力，5G必须寻找新的出路。 出路有哪些呢？ 首先，就是微基站。 微基站首先基站有两种，微基站和宏基站。看名字就知道，微基站很小，宏基站很大！ 宏基站：室外常见，建一个覆盖一大片 微基站：小的，估计只有巴掌那么大。 其实，微基站现在就有不少，尤其是城区和室内，经常能看到。 以后，到了5G时代，微基站会更多，到处都会装上，几乎随处可见。 那么多微基站在身边，会不会对人体造成影响？答案是——不会！ 其实，和传统认知恰好相反，事实上，基站数量越多，辐射反而越小！ 涉想一下，冬天，一群人的房子里，一个大功率取暖器好，还是几个小功率取暖器好？ 基站小，功率低，对大家都好。如果只采用一个大基站，离得近，辐射大，离得远，没信号，反而不好！ 天线去哪了？以前大哥大都有很长的天线，早期的手机也有突出来的小天线，为什么现在我们的手机都没有天线了？ 其实，我们并不是不需要天线，而是我们的天线变小了。 根据天线特性，天线长度应与波长成正比，大约在1/10~1/4之间。 随着时间变化，我们手机的通信频率越来越高，波长越来越短，天线也就跟着变短！ 毫米波通信，天线也变成毫米级… 这就意味着，天线完全可以塞进手机的里面，甚至可以塞很多根… 这就是5G的第三大杀手锏——Massive MIMO（多天线技术） MIMOMIMO就是“多进多出”（Multiple-Input Multiple-Output），多根天线发送，多根天线接收。 在LTE时代，我们就已经有MIMO了，但是天线数量并不算多，只能说是初级版的MIMO。 到了5G时代，继续把MIMO技术发扬光大，现在变成了加强版的Massive MIMO（Massive：大规模的，大量的）。 手机里面都能塞好多根天线，基站就更不用说了。 以前的基站，天线就那么几根： 5G时代，天线数量不是按根来算了，是按“阵”…“天线阵列”…一眼看去，要得密集恐惧症的节奏… 不过，天线之间的距离也不能太近。 因为天线特性要求，多天线阵列要求天线之间的距离保持在半个波长以上。如果距离近了，就会互相干扰，影响信号的收发。 一个能把直的掰弯的技术大家都见过灯泡发光吧？ 其实，基站发射信号的时候，就有点像灯泡发光。 信号是向四周发射的，对于光，当然是照亮整个房间，如果只是想照亮某个区域或物体，那么，大部分的光都浪费了… 基站也是一样，大量的能量和资源都浪费了。 我们能不能找到一只无形的手，把散开的光束缚起来呢？ 这样既节约了能量，也保证了要照亮的区域有足够的光。 答案是：可以。 这就是——波束赋形！ 波束赋形波束赋形：在基站上布设天线阵列，通过对射频信号相位的控制，使得相互作用后的电磁波的波瓣变得非常狭窄，并指向它所提供服务的手机，而且能跟据手机的移动而转变方向。 这种空间复用技术，由全向的信号覆盖变为了精准指向性服务，波束之间不会干扰，在相同的空间中提供更多的通信链路，极大地提高基站的服务容量。 直的都能掰成弯的…还有什么是通信专家干不出来的？ 在目前的移动通信网络中，即使是两个人面对面拨打对方的手机（或手机对传照片），信号都是通过基站进行中转的，包括控制信令和数据包… 而在5G时代，这种情况就不一定了。 Device to Device5G的第五大特点——D2D，也就是Device to Device（设备到设备）。 5G时代，同一基站下的两个用户，如果互相进行通信，他们的数据将不再通过基站转发，而是直接手机到手机… 这样，就节约了大量的空中资源，也减轻了基站的压力。 不过，如果你觉得这样就不用付钱，那你就图样图森破了。 控制消息还是要从基站走的，你用着频谱资源，运营商爸爸怎么可能放过你… 今晚了解了一些5G通信网络方面的知识点，真是 interesting~!!!]]></content>
      <categories>
        <category>通信技术</category>
      </categories>
      <tags>
        <tag>4g</tag>
        <tag>5G</tag>
        <tag>波长</tag>
        <tag>频率</tag>
        <tag>微基站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端自适应之rem布局]]></title>
    <url>%2F2018%2F12%2F16%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94%E4%B9%8Brem%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[web端和移动端其实有很大的区别。web端主要是考虑兼容性的问题，特别的是IE，面试题一堆的都是更兼容性有关的。移动端主要考虑的是自适应问题。 常用的flex &amp; table-cell ， rem &amp; grid。个人尝试之后，觉得通过定位+flex+rem这一套组合拳，基本可以完成页面的布局和自适应操作。 其中值得一提的是rem布局。对根元素设定可以有两种途径。 根元素设定js动态计算123456789101112131415161718 /*计算根font-size*/ (function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; if (clientWidth &gt;= 640) &#123; docEl.style.fontSize = '100px'; &#125; else &#123; docEl.style.fontSize = 100 * (clientWidth / 640) + 'px'; &#125; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); 这是网上的传统做法，上述为640的原型图的例子。 css途径1html&#123;font-size: calc(100vw/10.8);&#125;/*rem布局,适用于移动端*/ 第二种真是极其简单！用到了vw，即Viewport Width视口宽度。 移动端有三个视口，分别是 Layout Viewport（布局视口）、 Visual Viewport（视觉视口）、Ideal Viewport。它指的是Layout Viewport。 即相对于视口的宽度。视口被均分为100单位的vw。上述为1080的原型图的例子。 记得在一本书上看到过一句话印象深刻，能用CSS解决的问题就不用JS去写！]]></content>
      <categories>
        <category>移动前端开发之路</category>
      </categories>
      <tags>
        <tag>移动前端开发</tag>
        <tag>自适应</tag>
        <tag>rem布局</tag>
        <tag>根font-size</tag>
        <tag>vw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI的UI组件的使用记录]]></title>
    <url>%2F2018%2F12%2F16%2FMUI%E7%9A%84UI%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[过去两个多月时间，没有更新个人博客 - -来张家港实习三个星期了。入坑移动前端开发。由于学到的东西有点多，重新打开博客记录一下。 编辑器Hbuilder使用了一个原来没用过的软件，接触到的时候下载了 Hbuilder X 版本，新版比旧版更为简洁，但是会有令人烦躁的闪退现象。所以使用比较稳定的旧版。大致的操作和其他编辑器区别不大，主要是有个边看边改的模式，和android studio 类似，可以看到样式排版，但是实际操作过程中发现，还是直接使用chrome浏览器的手机调试模式更加准确快捷。其次，有个rem和px的转化倍数可以在设置中进行调整，也比较方便。最后，虽然语法支持中有es6的语法支持，但是，实际开发过程中，es6代码会在调试中报错，实属正常现象（估计是BUG），开发主要还是以chrome浏览器为准。 MUI框架来的第一个星期就要求我自学MUI的UI，这是一个移动端专属的框架，后续的平台开发应该会使用VUE框架。该框架根据官方文档自行查阅如何使用应该是没什么问题的。但是在后来的几个页面中，该框架用到的其实并不多，有时候还不如自己写来得快，具体情况还是根据原型图。这里记录几个小问题。 时间选择器 时间选择器,若要指定选中的时间，使用参数value，同时时间格式为’2018-12-16’,才能生效。 时间选择器的基础上做到点击指定区域对时间的递增或递减 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859let leftbtn = document.querySelector('.left');let rightbtn = document.querySelector('.right');let timebefore = document.querySelector('.before');let timeafter = document.querySelector('.after');let today = new Date();timeafter.innerText = today.format('yyyy-MM-dd');today.setDate(today.getDate()-2);timebefore.innerText = today.format('yyyy-MM-dd');//左按钮点击leftbtn.addEventListener('tap',function()&#123;this.style.background = 'url("../images/Previous.png") no-repeat center/contain';rightbtn.style.background = 'url("../images/Previous2.png") no-repeat center/contain';let today = new Date(timebefore.innerText);today.setDate(today.getDate()-1);timebefore.innerText = today.format('yyyy-MM-dd');&#125;);//右按钮点击rightbtn.addEventListener('tap',function()&#123;this.style.background = 'url("../images/Previous11.png") no-repeat center/contain';leftbtn.style.background = 'url("../images/Previous1.png") no-repeat center/contain';if(new Date().toDateString()!= new Date(timeafter.innerText).toDateString())&#123;let today = new Date(timeafter.innerText);today.setDate(today.getDate()+1);timeafter.innerText = today.format('yyyy-MM-dd');&#125;&#125;);//左时间段插件弹出timebefore.addEventListener('tap',function()&#123;let dtpicker = new mui.DtPicker(&#123;type: 'date',beginDate: new Date(2010,0,1),endDate: new Date(timeafter.innerText),value: timebefore.innerText&#125;);dtpicker.show(function(res)&#123;timebefore.innerText = res.text;this.dispose();&#125;);&#125;);//右时间段插件弹出timeafter.addEventListener('tap',function()&#123;let dtpicker = new mui.DtPicker(&#123;type: 'date',beginDate: new Date(timebefore.innerText),endDate: new Date(),value: timeafter.innerText&#125;);dtpicker.show(function(res)&#123;timeafter.innerText = res.text;this.dispose();&#125;);&#125;); 结构简单的，直接使用innerText 即可。 由于格式需要，使用了format.js来转化时间格式, 值得注意的是这类工具最好单独写并放在JS文件中，最后再引入。 123456789101112131415161718192021/*format*/Date.prototype.format = function(fmt) &#123; var o = &#123; "M+" : this.getMonth()+1, //月份 "d+" : this.getDate(), //日 "h+" : this.getHours(), //小时 "m+" : this.getMinutes(), //分 "s+" : this.getSeconds(), //秒 "q+" : Math.floor((this.getMonth()+3)/3), //季度 "S" : this.getMilliseconds() //毫秒 &#125;; if(/(y+)/.test(fmt)) &#123; fmt=fmt.replace(RegExp.$1, (this.getFullYear()+"").substr(4 - RegExp.$1.length)); &#125; for(var k in o) &#123; if(new RegExp("("+ k +")").test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : (("00"+ o[k]).substr((""+ o[k]).length))); &#125; &#125; return fmt;&#125; 滚动scroll经常会遇到的问题通常就是两种：隐藏进度条但是保持滑动功能，和 禁止滚动。 隐藏进度条但是保持滑动： 123456789/*普通情况的滚动条隐藏*/.ul1::-webkit-scrollbar&#123; display: none; &#125;/*隐藏MUI的滚动条*/.mui-scrollbar &#123; display: none !important;&#125; 上述两个情况写法原理一致，其中.ul1 是滑动的容器的选择器名称，根据需要自行修改。 禁止滚动： 12&lt;body style="overflow-y: hidden"&gt;&lt;/body&gt; 这是禁止竖直方向的滚动。 遮罩涉及到的遮罩问题和问题处理通过实际开发情况记录。功能需求： 一个导航栏有四个标题部分，每个标题部分下添加下拉菜单，点击为该标题部分，实现下拉菜单的显示和隐藏，其中除了该标题部分和下拉菜单外都是遮罩部分，且遮罩要设置为透明。 在其中一个下拉菜单中，添加两个时间选择器，分别处于第一和第二行，第三行为‘搜索’，第四行为默认。 可在该下拉菜单中选择起始时间和结束时间，点击时间进行选择的时候弹出时间选择器，此时下拉菜单不能隐藏，选完时间以后，点击‘搜索’再根据选择的时间去请求ajax数据。 ‘默认’为重置时间选择器的时间且刷新数据为默认时间范围内的数据。 下拉菜单的显示和隐藏 即 display：block 和 display : none 进行切换即可。 遮罩的显示和隐藏 1234567891011121314151617181920212223242526272829303132333435363738/*下拉菜单*/var p1 = document.getElementById('popover1');var p2 = document.getElementById('popover2');var p3 = document.getElementById('popover3');var p4 = document.getElementById('popover4');/*小图片*/var img1 = document.getElementById('img1');var img2 = document.getElementById('img2');var img3 = document.getElementById('img3');var img4 = document.getElementById('img4');var mask1 = mui.createMask(function ()&#123; p1.style.display = 'none'; p2.style.display = 'none'; //点击外部隐藏 p3.style.display = 'none'; p4.style.display = 'none'; img1.setAttribute('class','retransform'); img2.setAttribute('class','retransform'); img3.setAttribute('class','retransform'); img4.setAttribute('class','retransform'); return true;&#125;); /*显示菜单 显示遮罩*/mui('.nav_content').on('tap','.nav_1',function ()&#123; p1.style.zIndex = '999'; mask1.show();//显示遮罩 /*下拉菜单显示 和 图标旋转的判断*/ if (p1.style.display == 'block')&#123; p1.style.display = 'none'; img1.setAttribute('class','retransform'); mask1.close(); &#125;else&#123; p1.style.display = 'block'; img1.setAttribute('class','transform'); &#125;&#125;) 1234567891011121314var ul2 = document.getElementById('ul2');mui('.nav_content').on('tap','.nav_2',function ()&#123; p2.style.zIndex = '999'; mask1.show();//显示遮罩 if (p2.style.display == 'block')&#123; ul2.style.display = 'none'; img2.setAttribute('class','retransform'); mask1.close(); &#125;else&#123; p2.style.display = 'block'; img2.setAttribute('class','transform'); &#125; ul2.style.display = 'block';&#125;) 1234567891011121314151617181920212223mui('#ul2').on('tap','li',function(event)&#123; var cc = this.innerText; if(cc == '搜索')&#123; starttime = time1.innerText; endtime = time2.innerText; lists.innerHTML = ''; getData(); &#125; else if(cc == '默认')&#123; //重置默认开始时间 starttime = '2017/04/25'; //重置默认结束时间 endtime = '2018/10/01'; time1.children[0].innerHTML = '2017/04/25'; time2.children[0].innerHTML = today; lists.innerHTML = ''; getData(); &#125; else &#123; event.stopPropagation(); p2.style.zIndex = '998'; &#125;&#125;) 其中三个标题部分都类似第一部分的代码即可做到普通遮罩的效果。第二部分代码是第一部分代码做了点修改，即是对ul2的display的变动，因为我的布局是p2下的子元素是ul2,ul2下有四个li。第三部分主要是else中阻止了事件冒泡，this.innerText是像判断点击了哪个li,如果不阻止事件冒泡，会打印出父元素的文字。 还有就是改变z-index。让遮罩可以覆盖ul2，避免多次点击事件选择器，产生多个。 学无止境。]]></content>
      <categories>
        <category>移动前端开发之路</category>
      </categories>
      <tags>
        <tag>移动端前端开发</tag>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb数据库连接的变化]]></title>
    <url>%2F2018%2F10%2F06%2Fmongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[今天遇到一个连接的参数错误的问题。网上没找到解决方案。自己去文档查询了一下。 文档useNewUrlParser - 底层的MongoDB驱动程序已弃用其当前的连接字符串解析器。因为这是一个重大更改，所以他们添加了useNewUrlParser标志，以允许用户在新解析器中发现错误时回退到旧解析器。useNewUrlParser: true除非阻止您连接，否则应设置。请注意，如果指定useNewUrlParser: true，则必须在连接字符串中指定端口，例如mongodb://localhost:27017/dbname。新的URL解析程序不支持没有端口，如连接字符串mongodb://localhost/dbname。 解决如下：1mongoose.connect('mongodb://localhost:27017/pets',&#123;useNewUrlParser: true&#125;);]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css的基础回顾4]]></title>
    <url>%2F2018%2F07%2F26%2Fcss%E7%9A%84%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE4%2F</url>
    <content type="text"><![CDATA[背景样式背景颜色background-color 背景颜色 其中transparent为透明色，效果和不设置类似。因为用户对浏览器颜色进行设置可能会影响设计。 值得注意的是背景区域内，内容，padding内边距，边框有效，但是margin外边距不包括。 背景图片background-image 背景图片 和背景颜色一样，背景区域内，内容，padding内边距，边框有效，但是margin外边距不包括。 如果同时设置了背景颜色和背景图片的话，那么背景图片会覆盖背景颜色。 列表列表项标记list-style-type 设置列表项的标记样式类型。无序列表none 无disc 实心的圆点circle 空心的圆点square 实心的方块 有序列表none 无decimal 从1开始的整数lower-roman 小写罗马数字upper-roman 大写罗马数字lower-alpha 小写英文字母upper-alpha 大写英文字母 list-style-image 使用图片设置列表项的标记]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>温故知新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10系统开始菜单等左键没反应]]></title>
    <url>%2F2018%2F07%2F26%2Fwin10%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%A7%8B%E8%8F%9C%E5%8D%95%E7%AD%89%E5%B7%A6%E9%94%AE%E6%B2%A1%E5%8F%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[遇到的问题今天偶然发现win10系统出问题了。 左键想点击任务栏的WIFI图标查看WIFI列表时，发现点击没有反应。声音图标也左键也无反应。甚至连开始菜单左键都没反应。 虽然左键无反应，但是右键有反应。 解决办法上网查询了许久，且试用了多种方法之后。最终得到一种有效的解决办法。 在键盘上按下win+R键，或在开始菜单图标上点击右键选择运行 输入powershell，按下“确定”运行 在窗口里输入或复制粘贴以下命令，注意只有一行： Get-AppxPackage | % { Add-AppxPackage -DisableDevelopmentMode -Register “$($_.InstallLocation)\AppxManifest.xml” -verbose } 点击enter键，等待修复命令运行完成，完成之后BUG就被修复了]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>故障解决</tag>
        <tag>win10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初次尝试微信小程序的经验以及感悟]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%8F%E9%AA%8C%E4%BB%A5%E5%8F%8A%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[尝试2018年7月18号，偶然得到一个机会，给某公司制作一个微信小程序。主要功能就是其公司基本信息，产品，工程项目等等情况的展示。但是由于自己从来没有过微信小程序，也是有点担心做不出来，并没有马上答应。而是去看了以下微信小程序的开发者文档。经过一两个小时的摸索，逐渐发现门道。 其实微信小程序的开发本质上还是用到了网站开发的基础。例如html,css,js等。但是还是在开发过程中遇到的问题发现其具有一定的局限性，并不适合开发大型高性能级别的产品。 首先这个微信小程序文件大小有限制，不能超过2M. 我在上传代码时就遇到了这个问题。本身这个小程序没有什么特别的功能，但是需要一定量的图片展示。就对于图片的存放问题我也想了一下，图片说多也不多，说少也不少。如果存放在类似七牛云存储的东西上似乎也没必要。反而还得不偿失。用户可能因为网络问题会有不好的用户体验，直接放在这2M的文件下很尴尬，但是又很好的用户体验，即点开小程序就能马上看到完整的图片。 后来我想说直接缩小每个图片的大小好了，一开始电脑上直接操作还没注意，但是用自己手机测试小程序时，万万没想到，直接缩小图片居然使图片模糊不清！经过度娘搜索得到的办法是：将图片右键编辑，图片先保存，这时候图片大小会变大（具体原因不知），然后图片宽高比例不变的情况下缩小图片到一定程度（也不能缩小得太小），即可在手机端看到和原图清晰度相差不多得图片。 组件都已经封装好，直接看着文档选用即可。但是组件少且不灵活。 一开始我觉得还挺方便的，不需要自己单独去写，节省了很多时间，但是过程中我觉得其实微信小程序里的组件和相对应的一些属性并不完备，难免有掣肘之时。或许在今后的版本更新会有更好地完善。也可能是我个人没有深入花时间掌握。 屏幕大小的不同会影响页面的美观以及用户体验。 之前尝试过bootstrap，觉得这个框架很不错。应该嵌入小程序。虽然说可以通过一些方式去应对屏幕大小不同而导致的问题。但是这也有点浪费时间。开发过程中，我用好几个手机机型的模拟器去测试页面所展示的效果，手机端还好，但是平板这类相对于较大的屏幕就会有比较怪异的现象。 除此之外，在APPid上我也摔了跟头，拿着默认的测试id一直上传代码无结果让我差点怀疑人生。还有我原本以为需要购买服务器，后来发现这个静态页面不仅不需要，而且微信这个代码的审核速度也挺快的，平均两三个小时之内就能审核通过。综合而言，这次体验感觉还挺不错的，虽然这次的小程序没什么技术含量，但是对微信小程序整体开发有了一个简单的了解。 感悟生态圈和用户流量就跳出开发微信小程序而言。和传统的app相比较，其实很多是小程序无法做到的，但是时代和趋势下，如今国内掌控用户数量最大的app莫过于微信了，小程序的遍地开花现象也是必然，但是良莠不齐，和如今市面上一大堆的app差不多，能真正做到拥有一定用户的在少数。各个商家都不断往里涌入，其实无形之中逐渐形成了微信自己的生态圈。通讯社交能在微信里做到，购买火车票，购买电影票等等的一些支付操作都能在微信做到，音乐也能在微信里听，文章也能在微信里看，视频也能看，哪怕现在还有局限性。等等一大堆的功能其实已经让一部分用户觉得，没有必要安装其他的app，在微信里也能做到，移动互联网时代有这样的微信存在，无疑是对其他app的打击，更是对手机厂商得打击。毕竟很多手机厂商，都有为用户预装app这一块的利润可以拿，而且在现如今各个手机厂商的价格战也是一家比一家狠，手机市场也越来越难做，最终肯定是有人会被淘汰。这也难怪几个手机厂商联合起来搞了一个叫快应用的东西。但是我觉得这东西比较尴尬。存在的意义都难以理解。总之，我觉得移动互联网的市场已经趋于饱和，哪怕现在一些app也模仿着做自己的小程序，但是这个用户流量已经被控制在微信上了，一时半会儿是没有机会的。 用户认知和负责宣传推广的项目经理交流过程中，也让我有一些思考。不管是做网站，然后请人做SEO，或者微信小程序，还有微博推广，广告投入等等途径，我觉得本质上就是要占领一个关键的东西，叫“用户认知”。我第一次听到这个词的时候还是在大三上学期看逻辑思维演讲。当时觉得罗胖说得有点对，现在又想了想，这个词真的是非常厉害。曾经，我一度愚昧地认为广告地投入是多么的浪费时间和金钱，因为我觉得说谁没事喜欢看广告，正常情况下都是挑自己喜欢看的东西，尽力去避免自己花时间看广告。后来我发现我错了。自己只能是尽力去避免，却无法真正地完全地避免，自己还是在无形之中收看了大量的广告，而且那些多次出现在我眼前的，或者是具有特色的广告让我一不小心地给记下了了。自己不经意间，想买鞋或许第一瞬间会想到安踏，想买空调第一时间可能想到美的，想买手机第一时间可能想到华为等等。包括我之前和我妈在一起看电视的时候，我妈突然问我，“电视上那个vivo手机真的有那么好吗？我最近想换一部手机买vivo怎么样？”我当时还笑着给她推荐了几款其他类型的手机给她比较。现在想想，其实我对vivo印象也很一般，但是不记得它什么时候开始扎进我的脑子里的，很神奇的是我并不知道vivo的产品有多好，但是每次广告都有它，不小心给记住了。或许不同的公司在不同的平台会投放广告，但是占领用户认知的手段却不止用广告这一种。就小米公司而言，我觉得一开始可能有人都不看好这公司，诸如“竞争对手过于强大”，“价格战”，“饥饿营销”等等关键词。无论经历了何种社会舆论和来自对手的打击，最终的结果所有人都有目共睹。现在已经在和华为这样的老牌大厂抢市场了。且大多数人都知道他们家的手机“便宜”，“性能强”等等。哪怕之前几乎不盈利，现在的回报真的令人汗颜。抢占了用户认知的重要性不言而喻。相比于魅族公司，进入市场非常早，但是整体上都是在走下坡路，用户们包括我自己本身就是六年的魅族产品的持有者，对于魅族手机的认知，现在已经只剩“颜值高”，“系统简洁大方”了。加之它手机自己本身的问题，我觉得如果不做出改变，会逐渐被淘汰。 做生意是如此，做人亦是如此。三国之中魏国谋臣的杨修，才思敏捷，机智果断为世人所熟知。他极力表现自己，但是曹操对他的认知或许除了才思敏捷和机智果断之外，或许还多了急功近利，恃才傲物的标签。哪怕曹操多么爱才，关键时刻或忍无可忍之时，这样的人终究会沦为弃子。而同时期且为对手的司马懿，沉稳收敛，智计超群，目光长远且能以大局为重之人，一路小心谨慎辅佐着曹丕。在恰当的时间和场合去推销自己，占领他人对于自己的认知，才是明智之举。]]></content>
      <categories>
        <category>微信小程序开发</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>用户认知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css的基础回顾3]]></title>
    <url>%2F2018%2F07%2F04%2Fcss%E7%9A%84%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE3%2F</url>
    <content type="text"><![CDATA[文字样式文字样式属性 字体：font-family 例如宋体，微软雅黑，黑体等等。 文字大小：font-size in 英寸，1英寸=2.54厘米 cm 厘米，1厘米=0.394英寸 mm 毫米，1毫米=0.1厘米 pt 磅,72磅=1英寸 pc Pica,1pc=12pt 绝对单位的属性值： xx-small 9px x-small 11px small 13px medium 16px large 19px x-large 23px xx-large 28px 相对单位的属性值： px 像素 受显示器分辨率的影响。 em/% 文字颜色：font-color 主要有三种表现形式。 第一种可以用 颜色的英文单词。 第二种用 rgb(，，)，数值在0~255；百分比在0%~100%。 第三种用#开头的6位的16进制表示的数.例如#117700.不区分大小写，且可简写为#170. 文字粗细：font-weight 用来设置文字的粗细。 属性值有：normal/bold/bolder/lighter/100~900 默认值为normal,即400. bold即差不多等同于700。 文字样式：font-style 用来设置文字的倾斜状态。 属性值有：normal/italic斜体/oblique倾斜 字体变形：font-variant 设置元素中，文本为小型大写字母。 属性值有：normal/small-caps 文本样式 text-align(只对块级元素的设置有效，例如div) 设置元素内文本的水平对齐方式。 属性值有：left/right/center/justify两端对齐 vertical-align(只对行内元素有效，例如span,img) 设置元素内容的垂直方式。 属性值有：sub下标/super上标 top/text-top/middle/baseline(默认)/text-bottom/bottom 长度/百分比 正值为基于基线上移，负值是基于基线下移。 单行文字垂直居中123456.text&#123; height:400px; width:100px; line-height:400px;//line-height是行间距离。 text-align:center;&#125; 多行文字垂直居中123456.text&#123; height:400px; width:100px; line-height:400px; text-align:center;&#125; 行高 line-height 若行高小于字体大小，会发生字体重叠现象。 所以行高尽量试用em或者%为单位。即无论字体大小变化为多少，行高会随之改变。 文本样式属性字体属性word-spacing 设置元素内单词之间的距离 letter-spacing 设置元素内字母之间的距离 text-transform 设置元素内文本的大小写，有四个属性值:capitalize设置首字母大写；uppercase将所有字母设置成大写；lowercase将所有字母设置成小写；none没有任何设置效果 text-decoration 设置元素内文本的装饰，属性值有：underline下划线；overline上划线；line-through贯穿线或者删除线；blink闪烁效果(有兼容性问题)；none没有任何效果]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>温故知新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css的基础回顾2]]></title>
    <url>%2F2018%2F07%2F04%2Fcss%E7%9A%84%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE2%2F</url>
    <content type="text"><![CDATA[CSS使用方法的区别 行内样式：在对应的标签内使用style。属于html文件内。同时加载。 内部样式：在head标签下的style标签中。属于html文件内。同时加载。 链入外部样式：在head标签下使用link进行引用。属于单独的css文件，和html文件分离。页面加载时，同时加载css样式。（常用） 导入式：在样式代码追开始处通过@import进行导入外部文件。也属于单独的css文件，和html文件分离。但是是在读取完html文件之后才加载。（慎用！） 使用方法的优先级行内样式&gt;内部样式&gt;外部样式 其中，链入外部样式和内部样式之间的优先级取决于所处位置的先后。最后定义的优先级最高（即就近原则）。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>温故知新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html的基础回顾3]]></title>
    <url>%2F2018%2F07%2F04%2Fhtml%E7%9A%84%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE3%2F</url>
    <content type="text"><![CDATA[表单from标签即表单标签。又包含了 input标签，select标签，option标签，textarea标签。 input标签表单输入标签。单标签。 input标签的type属性 text 单行文本域 name 文本域名称。 maxlength 指用户输入的最大字符长度。 size 指定文本框的宽度，以字符个数为单位。且文本框的缺省宽度是20个字符。 value 指定文本框的默认值。 placeholder 规定用户填写输入字段的提示。 password 密码域 可以密文输入。 file 文件域 通常是文件上传操作时使用。 checkbox 复选域 复选框的name不影响选择。但是若有多个复选框的情况，为了让服务器知道是哪个复选框发来的数据，那么应该让同一组的复选框取相同的name来区分辨别。 其他的和单选框类似。 radio 单选域 常见的例如性别选择的使用。 主要避免错误的是，若要多个域选一个的情况，那么应该将这多个input下的属性name设置为相同的name。 默认选中的设置可以在对应的input下添加 “ checked ” 。表明该条是选中状态。 其中，radio中的value属性值，这个值虽然不会像text单行文本域中设置的那样显示出来，但是点击选中的域后，即可把该域对应的value上传到服务器。 button 按钮 submit 提交按钮 reset 重置按钮 hidden 隐藏域 value值是点击按钮时提交给服务器的值。 image 图像域(图像提交按钮) 功能和submit提交按钮一样，只是好看一点。 select标签下拉菜单和列表标签。 常和option标签搭配使用。 其中value的值是传送给服务器的。 如下是一个下拉菜单的例子。 123456789&lt;select name="city"&gt; &lt;option value="xz"&gt;--请选择--&lt;option/&gt; &lt;option value="bj"&gt;北京&lt;option/&gt; &lt;option value="js"&gt;江苏&lt;option/&gt; &lt;option value="fj"&gt;福建&lt;option/&gt; &lt;option value="gd"&gt;广东&lt;option/&gt; &lt;option value="yn"&gt;云南&lt;option/&gt; &lt;option value="hn"&gt;海南&lt;option/&gt;&lt;select/&gt; 如下是一个列表的例子。 其中size是用来设置选项的条目。如条目超过6个会有滚动条。 multiple即设置为 可多选。 若上面的代码也添加multiple，则会自动变成列表展示的形式。同时也可以多选。 12345678&lt;select name="city" size="6" multiple&gt; &lt;option value="bj"&gt;北京&lt;option/&gt; &lt;option value="js"&gt;江苏&lt;option/&gt; &lt;option value="fj"&gt;福建&lt;option/&gt; &lt;option value="gd"&gt;广东&lt;option/&gt; &lt;option value="yn"&gt;云南&lt;option/&gt; &lt;option value="hn"&gt;海南&lt;option/&gt;&lt;select/&gt; option标签即下拉菜单和列表项目标签。 属性selected 设置选项初始选中状态。 属性value 定义送往服务器的选项值。 optgroup标签即下拉菜单和列表项目分组标签。 例子如下： 123456789101112&lt;select name="city"&gt; &lt;optgroup label="区域一"&gt; &lt;option value="bj"&gt;北京&lt;option/&gt; &lt;option value="js"&gt;江苏&lt;option/&gt; &lt;option value="fj"&gt;福建&lt;option/&gt; &lt;optgroup/&gt; &lt;optgroup label="区域二"&gt; &lt;option value="gd"&gt;广东&lt;option/&gt; &lt;option value="yn"&gt;云南&lt;option/&gt; &lt;option value="hn"&gt;海南&lt;option/&gt; &lt;optgroup/&gt;&lt;select/&gt; textarea标签即多行文本域标签。 多行文本域的属性 name 设置文本区域的名称。 placeholder 设置描述文本区域预期值的简短提示。 rows 设置文本区内的可见行数。 cols 设置文本区内的可见宽度。 form标签的其他属性action提交表单时向何处发送表单数据。 属性值为 URL.或者可以说是提交表单后处理数据的文件。 method设置表单以何种方式发送到指定页面。 属性值有： get：通常是用来查询一些数据的情况下使用。因为get是使用url传递参数，会把数据暴露出来。同时get对所发送的信息的数量也有限制。 post：通常用来修改服务器上的数据。使用post时，表单数据会作为http请求体的一部分，具有一定的保密性，且对所发送信息的数量无限制。 name表单的名称。 target在何处打开action的URL。 属性值有： _blank 在空页面打开。 _self 在当前页面打开。默认值。 _parent _top enctype在发送表单数据之前如何对其进行编码。 属性值为： application/x-www-form-urlencoded 在发送前编码所有字符，在发送到服务器之前，所有字符都会进行编码（空格转换为 &quot;+&quot; 加号，特殊符号转换为 ASCII HEX 值）。默认方式。 只能上传文本格式的文件。 multipart/form-data 不对字符编码。 是将文件以二进制的形式上传，这样可以实现多种类型的文件上传。包含上传控件的时候使用。 text/plain 空格转换为 &quot;+&quot; 加号，但不对特殊字符编码。 是将文件设置为纯文本的形式，浏览器在获取到这种文件时并不会对其进行处理。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>温故知新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于国产操作系统的思考]]></title>
    <url>%2F2018%2F07%2F04%2F%E5%AF%B9%E4%BA%8E%E5%9B%BD%E4%BA%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[摘要 时代不断地在进步，科技不断得在提升，享用美好事物的同时我们也得接受面对并且去解决其背后的问题。 操作系统广泛用于各个行业，也是国家关键基础设施运行的关键,随着操作系统的逐渐开放和发展，暴露出许多严重的问题。本文着重从操作系统的垄断情况，和目前国产操作系统所面临的主要威胁，来揭露拥有国产操作系统的重要性。并且通过分析和对比来简述我国国产系统的发展情况。同时结合当下情况，针对操作系统的发展产生一些思考和建议。 引言美国发出对中兴七年禁售令事件之前引起了许多人的关注。其实在电子科技领域。2017年全球采购芯片最多的十个公司，可以看到全球前十名中有三家中国公司，联想，华为，步步高电子，排在世界第4-6位。在2017年，联想采购了146.71亿美元芯片；华为采购了142.59亿美元的芯片；步步高采购了121.03亿美元的芯片。显然很大程度上中国市场需要美国的技术支持。同样的在操作系统领域，国内普遍也受制于微软和谷歌，苹果。这值得我们思考。 拥有国产操作系统的重要性操作系统的垄断情况有人觉得航空飞机的垄断性最强，航空飞机被波音、空客所垄断，总数量也可能只是数十万级别。但全世界几十亿台智能终端只有三种操作系统：苹果、安卓和windows，这种垄断在全世界找不到第二例。从网络安全角度，中国要成为网络强国，必须解决智能终端操作系统被垄断的问题。中国在信息核心技术领域，尤其是CPU和操作系统这两方面的弱势很明显。美国能够引领信息领域，重要原因便是掌握了CPU、操作系统这两项核心技术。 主要威胁第一，在互联网时代，无论是个人电脑、智能终端的应用，还是互联网、物联网、云计算、大数据的各种服务和应用，操作系统都是其中不可或缺的重要组成部分，其基础性地位和作用无可替代。对计算机系统的攻击和威胁，操作系统往往成为主要的目标。也正因为如此，操作系统的安全就显得尤其重要。第二，没有自主研发的操作系统，随时都有可能被“断粮”！就正如安卓系统，谷歌随时都可以在上面做手脚，让国内大部分的手机厂商受到打击，这也非常容易影响国内的经济发展。 国产操作系统的发展中科红旗的起步、成长与衰败，几乎就是国产操作系统艰难求索的缩影。2017年安卓系统市场占有率达85.9%，苹果IOS为14%。其他系统仅有0.1%。那0.1%，基本也来自美国：微软的Windows和黑莓。韩国三星也曾在2013年推出Tizen系统，试图打破垄断，但如今三星手机还在使用安卓。早在2012年就爆出华为麒麟OS研发消息，直到现在该系统基本已经成型，但是还没有到发布的火候。因为目前安卓系统已经成熟，没必要发布自家的移动操作系统。而是作为一种备用资源，未来如果安卓闭源或者受到类似中兴的命运，或许这时候才是华为系统亮相的时机。前有失败者的教训，大家都不愿意再冒险，这种费时费力又不一定能取得经济效益的事情，都选择面面相觑，静待时机。导致国产操作系统的发展缓慢甚至几乎停滞不前。对于开发者而言，目前无疑是针对android开发和ios开发去学习和研究，毕竟这是能糊口的工作。底层劳动人民更别谈有什么远大的抱负和理想去改变国产操作系统的未来了。再相比于美国，他们对于计算机人才的培养和发展远远领先于我们，对于操作系统的远见和探索也领先于我们。输在起跑线已然成为事实。 国产操作系统的发展任重而道远。 思考和建议云计算、大数据、物联网时代，各种智能终端、可穿戴设备，包括家电、汽车、工控系统成为人们必备的终端产品，传统的技术、产品和安全体系都面临着巨大的安全风险。我们如何在微软、苹果、谷歌三巨头独霸市场的夹缝中，适时把握战略机遇，谋求生存发展空间，创新机制体制，培育完整产业体系，推动国产操作系统向真正的自主可控迈进呢？首先。我觉得通过中兴事件已经给我们敲响了一个警钟。这已经不是各个公司之间的商业竞争层面的问题了，已经上升到国于国核心竞争力的问题了。正如对于人工智能而言，我国政府的大力支持和倡导，引发了许多有志青年奔向这个领域去奋斗。甚至目前随之大热的语言python也备受瞩目，许多小朋友都已经开始在学习了。同样的，国家如果能够更加重视到操作系统这个领域。通过政策和资金去支持开发者，我相信华夏如此泱泱大国也能有独当一面的操作系统。其次。操作系统很需要生态环境去让它发展和生存。我觉得需要联合各大厂商，大家同仇敌忾，一起去支持国产操作系统的发展。然后对于开发者而言，应该高新聘请这方面的人才，共同思考和解决一系列的问题。中国有很优秀的个体，比哪个国家都不差。因此，我们应当扬长避短，充分发挥中国的人才优势。短期内我觉得做到以上三点是可以在国内拥有自主研发的操作系统的。但是从长期的角度。创新性人才的培养也很关键。因为我的觉得当代的绝大数人的思维已经固化了。学习计算机时的一些固有思维，包括安卓系统也是，其实很多也是基于linux的一些思想，要做到完全自主研发的国产操作系统确实非常难。而我觉得，既然在市面上的操作系统都比较完备的情况下，且目前人工智能领域的研究还正在继续，如果将人工智能和操作系统两个领域相互结合，共同推进两个领域的发展，或许将颠覆以往所有的操作系统。授之以鱼不如授之以渔。 总结时代的步伐无法阻拦，我们必须顺应时代的潮流，哪怕在计算机技术水平落后于部分国家的情况下，也不能放弃人才的培养。当然了，世界上没有一尘不变的技术。我们不闭关锁国，不拒绝国外优秀先进的技术，但是我们必须要有能够自给自足的能力和与外界对抗的竞争力。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>国产操作系统</tag>
        <tag>安卓/linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html的基础回顾2]]></title>
    <url>%2F2018%2F07%2F03%2Fhtml%E7%9A%84%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE2%2F</url>
    <content type="text"><![CDATA[表格 table 表格标签 caption 表格标题 (居中显示) tr 行 th 表头单元格 (有居中和加粗的效果) td 单元格 带结构的表格若表格较为复杂的情况下，为了提高效率，让表格一边加载一边显示。且以下三个标签通常都是同时存在同时使用的。不影响布局，但是划分了表格的结构。 thead 表格的头 tbody 表格的主体 tfoot 表格的注脚 表格中的常用属性table标签 width 表格的宽度。 align 表格相对周围元素的对齐方式。 border 设置表格边框的宽度。 bgcolor 表格的背景颜色。 cellpadding 单元边缘与其内容之间的空白。 cellspacing 单元格与单元格之间的空白。 frame 规定外侧边框的哪个部分是可见。 rules 规定内侧边框的哪个部分是可见。 tr标签 align 行内容的水平对齐。 valign 行内容的垂直对齐。 bgcolor 行的背景色。 td标签 跨列属性colspan 跨行属性rowspan colspan例子： 1234567891011&lt;table&gt; &lt;tr&gt; &lt;td colspan="2"&gt;。。&lt;/td&gt; &lt;td &gt;。。&lt;td/&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;。。&lt;td/&gt; &lt;td&gt;。。&lt;td/&gt; &lt;td&gt;。。&lt;td/&gt; &lt;tr/&gt;&lt;table/&gt; 表格嵌套必须嵌套在td标签内！]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>温故知新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS原型链的理解]]></title>
    <url>%2F2018%2F05%2F12%2FJS%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例都包含一个指向原型对象的内部指针。 ——此段话摘自《JavaScript高级程序设计》。 原型链原型链的由来用构造函数生成实例对象，有一个缺点，那就是无法共享属性和方法! 所以出现了通过原型链实现”继承”的办法去共享一些属性和方法。 原型链注意问题在通过原型链实现”继承”时，不能使用对象字面量创建原型方法。因为这样做会重写原型链。 原型中包含引用类型值得问题 基本类型：Number Boolean String undefined null引用类型：Object Function 12345678910111213141516171819var a = new A(); function A()&#123;this.number = [ "一","二","三" ];&#125;console.log("a的属性："+a.number);//a的属性：一,二,三function B()&#123;&#125;B.prototype = new A();//B继承Aconsole.log("a指向的构造函数："+a.constructor);console.log("B的原型的构造函数："+B.prototype.constructor);var b1 = new B();var b2 = new B();console.log(b1.__proto__);console.log(b1.prototype);//undefinedconsole.log("b1在原型链中查到的属性："+b1.number);// b1在原型链中查到的属性：一,二,三console.log(b1.number.push("四"));//添加一个 "四" 返回数组的长度4console.log("b1在原型链中查到的属性："+b1.number);// b1在原型链中查到的属性：一,二,三,四console.log("b2在原型链中查到的属性："+b2.number);// b2在原型链中查到的属性：一,二,三,四 在A中定义了属性。接着让B去继承A，再创造B的两个实例b1和b2，通过实例b1能够查找到并且使用原型A的属性。这时候如果在实例b1中往属性number中push一个元素”四”。即修改了number。那么不仅仅b1这个实例能通过number属性查到”一，二，三，四”，而且b2也能查到。 我还尝试在b1使用属性prototype，发现结果为underfined。后来发现portotype是函数特有属性。即今后应该注意的是： 函数应该通过portotype访问原型，而实例对象应该通过proto访问原型。 解决办法一：继承者中调用被继承者的构造函数12345678910111213141516var a = new A(); function A()&#123;this.number = [ "一","二","三" ];&#125;function B()&#123; A.call(this);&#125;B.prototype = new A();//B继承Avar b1 = new B();var b2 = new B();console.log("b1在原型链中查到的属性："+b1.number);// b1在原型链中查到的属性：一,二,三console.log(b1.number.push("四"));//添加一个 "四" 返回数组的长度4console.log("b1在原型链中查到的属性："+b1.number);// b1在原型链中查到的属性：一,二,三,四console.log("b2在原型链中查到的属性："+b2.number);// b2在原型链中查到的属性：一,二,三 即通过call或者apply执行构造函数。 还有一个好处是可以传递参数 传递参数123456789function C(age)&#123; this.age=age;&#125;function D()&#123; C.call(this,20);&#125;D.prototype = new C();var d = new D();console.log(d.age);//20 存在的问题 如果仅仅是调用构造函数，那么也无法避免构造函数存在的问题，方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言是不可见的，结果，所有类型都只能使用构造函数模式，考虑到这些问题，借用构造函数的技术也是很少单独使用的。 —— 此段话摘自《JavaScript高级程序设计》]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js之如何接受前端数据请求]]></title>
    <url>%2F2018%2F05%2F11%2Fnode-js%E4%B9%8B%E5%A6%82%E4%BD%95%E6%8E%A5%E5%8F%97%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[前端向后端发送请求的通常有这几种方式：form,ajax,jsonp等等但是对于后端收到的请求性质都是一样的，都是通过http得到的请求。 请求方式： GET: 数据在URL中,用url模块解析。 POST: 数据不在URL中,用querystring模块解析。相对于“头”，“身体”更大，需要分块解析。]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>数据请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js之文件系统fs]]></title>
    <url>%2F2018%2F05%2F11%2Fnode.js%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Ffs%2F</url>
    <content type="text"><![CDATA[最近看了慕课网里的一个教学视频，自己也动手尝试在后端视角建立一个完整的网站。因为之前不管是html,css，js等等，折腾的都是属于前端的范畴。按照学校里老师的教学的话，是要我们装ASP,并且老师用的是C#来写后端，当然了还有网上说的可以用JAVA和PHP，但是鉴于时间有限，且目的在于了解前后端联合建站的一整套流程，我选择了用node.js搭了一个服务器，然后mongodb做数据库。经过测试，node.js特别好用！不仅巩固了计算机网络的知识，而且不会有太高的学习成本吧，还能练习一下javascript，对于初学者而言，何乐而不为呢。 服务器的请求和访问node.js自带了很多的模块，我最先用的是http模块。简单的导入模块后利用createServer创建一个服务器。参数也主要分别request和response。即请求和响应。 一开始用很土的办法—–switch-case-break分别case多个请求。如果当前请求属于这多个已经定义好的请求之一的话则成功访问，否者报错。 把文件放在服务器上后来想想觉得不对，我多个多个请求不能一个个去写。不仅浪费时间。而且有局限性。 最大的问题是这些已经定义好的请求或者写好的页面还是一些什么文件都是放置在服务器上的。如果我一旦修改case中的请求内容，全部又得重新从服务器获取。不断地重启服务器然后再允许访问肯定是不行的。 把文件放在磁盘上想法很简单，文件放在磁盘上，然后浏览器一旦告诉服务器有请求，服务器就从磁盘上读取文件并且响应请求给浏览器。 文件系统filesystemnode.js里的自带模块fs就特别方便。 12345678var server = http.createServer(function(req,res)&#123;var filename = "./text"+req.url;fs.writeFile(filename," hello! this is fs text",function(err)&#123; if(err)&#123; console.log(err); &#125; &#125;);&#125;); 写操作。需要的三个参数分别是需要写入文件的地址，写入的内容，回调函数。 1234567891011var server = http.createServer(function(req,res)&#123;fs.readFile(filename,function(err,data)&#123; if(err)&#123; res.write("404"); console.log(err); &#125;else&#123; res.write(data); &#125; res.end(); &#125;);&#125;); 读操作。需要的参数分别是需要读的文件的地址，回调函数。回调函数里面需要Error参数和需要读取的数据。 其中，值得注意的是res.end();写在这里的原因是因为同步异步机制。文件操作肯定是耗时的，即为异步任务。若写成以下情况，则报错。 1234567891011var server = http.createServer(function(req,res)&#123;fs.readFile(filename,function(err,data)&#123; if(err)&#123; res.write("404"); console.log(err); &#125;else&#123; res.write(data); &#125; &#125;);res.end();&#125;); 简单来说就是文件还没读完就执行res.end();了。]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>file system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结合异步理解闭包]]></title>
    <url>%2F2018%2F05%2F01%2F%E7%BB%93%E5%90%88%E5%BC%82%E6%AD%A5%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包想法的初步理解闭包的想法源于对Javascript本身这个语言的特点。 可以利用函数来划分作用域。且在函数中如果查找不到所需要的局部变量时就会“向上”查找。即如果没有函数嵌套，那么会去全局作用域里查找。但是在函数外部想访问内部变量时就做不到了。 简单且通俗地来说： 里面的可以看到外面的，外面的看不到里面的。后来极具智慧的人类在不改变语言规则的情况下，想出了“闭包”。 既然只能向上查找。那么就改变查找的“起始点”！！！简单来说，一个函数a内部的东西，通过函数a内部再创建一个函数b，通过这个函数b按照“向上”查找来得到这个函数a内部的东西。然后函数a的外部只需要调用函数b，即可获取函数a内部的东西。 这个闭包像个“内奸”。还控制着内部资源的生存时间。通常情况下，函数执行形成一个私有的作用域，当执行完成后就销毁了-&gt;节省内存空间。但是闭包反而会占用这个作用域不放。 所以滥用闭包反而会得不偿失。 循环和定时器结合使用的问题看到for循环结合定时器的例子的时候。真的是差点怀疑人生。 1234for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function timer()&#123; console.log(i);//每隔一秒打印一个5,总共打印5个5 &#125;, i*1000); 这就是我看到的一个例子。原本不假思索地认为输出结果应该是 0 1 2 3 4但是万万没想到。。。然后我就给上面的代码添加了一句，测试了下。测试代码如下： 123456for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function timer()&#123; console.log(i);//2.然后每隔一秒打印一个5,总共打印5个5 &#125;, 1000); console.log(i);//1.最先打印 0 1 2 3 4 &#125; 因为异步机制，所以先打印 0 1 2 3 4 是没错的。定时器仍然在这里打印了5个5.整体结合起来看，就说得通了。首先，同步任务不管放在哪里，肯定是先于这个异步任务–定时器，i的值一直打印直到i=5的时候这个同步任务就停止了。接着是异步任务开始打印，之前由于for循环每执行一次就创建出一个延时函数，执行了5次，就会有5个延时函数。这5个延时函数共享一个作用域（本例中全局作用域），且i又累加到5，所以会打印出5个5！！！ 解决思路当然是用闭包了。 立即执行函数12345678for (var i=0; i&lt;5; i++) &#123; (function() &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 ); // console.log(i); &#125;)(); &#125; 每个延迟函数都会将立即执行函数在每次迭代中创建的作用域封闭起来。但是结果任然是5个5。因为这个封闭的作用域是空的，且i是全局作用域里的变量。 立即执行函数的成功改进112345678for (var i=0; i&lt;5; i++) &#123; (function() &#123; var j = i; setTimeout( function timer() &#123; console.log( j ); &#125;, j*1000 ); &#125;)(); &#125; 通过声明一个局部变量j,并且传值赋值，即将i的值拷贝一份给j。虽然i和j值相同，但是i和j相互独立。i是全局变量，j是局部变量。每循环一次，就会拷贝一次并传递给j。并且每j秒打印一次j变量中的值。 立即执行函数的成功改进21234567 for(var i = 0; i &lt; 5; i++) &#123; (function(e) &#123; setTimeout(function() &#123; console.log(e); &#125;, i*1000); &#125;)(i);&#125; 《你不知道的javascript》一书中也出现了这个方式。这个改进似乎更简单，但是和改进1是同样的道理。因为js中函数传递参数就是按值传递的。 普通的自定义函数1234567function doSetTimeout(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, i*1000);//doSetTimeout包裹起来 &#125; for (var i = 0 ; i &lt; 5; i++)&#123; doSetTimeout(i);//自定义函数循环调用 // console.log(i); &#125; 同样的，自定义的函数也行。每次循环，都会调用一次doSetTimeout函数。且把i按值传递给定时器。然后定时器每i秒输出一次i的值。 如果在doSetTimeout函数中添加一句console.log(i);那么视觉效果上会瞬间打印出0 1 2 3 4 0然后每隔1秒接着打印完剩下 1 2 3 4。 用let来控制作用域块123456for (var i=0; i&lt;5; i++) &#123;let j = i; // 闭包的块作用域setTimeout( function timer() &#123;console.log( j );&#125;, j*1000 );&#125; 或者 12345for (let i=0; i&lt;5; i++) &#123;setTimeout( function timer() &#123;console.log( i );&#125;, i*1000 );&#125; 目测这是最简单粗暴的做法了。。 最后一句话概括闭包闭包是指有权访问另一个函数作用域中的变量的函数—-摘自Javascript高级程序设计]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水平垂直居中和position]]></title>
    <url>%2F2018%2F04%2F30%2F%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%92%8Cposition%2F</url>
    <content type="text"><![CDATA[看到网上的总结说有10种居中的方式。其实很多都有局限性，我选了一种最实用的且没有兼容性问题的水平垂直居中方式记录下来。 顺便复习了一下块级元素和内联元素以及各种position 块级元素（块级元素会默认占一行）address - 地址 blockquote - 块引用 center - 举中对齐块 dir - 目录列表 div - 常用块级容易，也是css layout的主要标签 dl - 定义列表 fieldset - form控制组 form - 交互表单 h1 - 大标题 h2 - 副标题 h3 - 3级标题 h4 - 4级标题 h5 - 5级标题 h6 - 6级标题 hr - 水平分隔线 isindex - input prompt menu - 菜单列表 noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容 noscript - ）可选脚本内容（对于不支持script的浏览器显示此内容） ol - 排序表单 p - 段落 pre - 格式化文本 table - 表格 ul - 非排序列表 内联元素a - 锚点 abbr - 缩写 acronym - 首字 b - 粗体(不推荐) bdo - bidi override big - 大字体 br - 换行 cite - 引用 code - 计算机代码(在引用源码的时候需要) dfn - 定义字段 em - 强调 font - 字体设定(不推荐) i - 斜体 img - 图片 input - 输入框 kbd - 定义键盘文本 label - 表格标签 q - 短引用 s - 中划线(不推荐) samp - 定义范例计算机代码 select - 项目选择 small - 小字体文本 span - 常用内联容器，定义文本内区块 strike - 中划线 strong - 粗体强调 sub - 下标 sup - 上标 textarea - 多行文本输入框 tt - 电传文本 u - 下划线 var - 定义变量 positionstatic：默认的文档流的布局的方式，块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。（忽略 top, bottom, left, right 或者 z-index 声明）。 relative：相对于原来的位置进行偏移，完成的过程是首先按static(float)方式生成一个元素，相对于以前的位置，移动方向和幅度由left、right、top、bottom属性确定，它原本所占的空间仍保留。 移动方向（借用象限辅助记忆） left+top: 均为正值的话是在第二象限进行移动 right+top: 均为正值的话是在第四象限进行移动 absolute：元素框从文档流完全删除，元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样，根据父容器（必须是非static的定位的容器）进行位置定位。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 fixed：固定在浏览器的某个位置，浏览器scroll时不会发生变化。 static就是默认的布局方式。 总结绝对定位根据父元素为基准点进行定位，它会脱离文档流，不占用原来位置空间相对定位根据自身为基准点进行定位，离开原位置，但是还是会占用原来位置空间固定定位根据浏览器窗口为基准点进行定位，它始终在一个位置，不会移动 好用的水平垂直居中方式12345678910111213141516171819body&#123; margin: 0 ;&#125;#father&#123; position: relative; background: aquamarine; width: 100%; height: 800px;&#125;#son&#123; background: gray; width: 200px; height: 200px; position: absolute; left: 50%; top: 50%; margin-left: -100px; margin-top: -100px;&#125; 原理:利用子元素的绝对定位，且父元素要用相对定位，这样就可以将div元素定位到中心点。再用margin进行调整。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>水平垂直居中</tag>
        <tag>position</tag>
        <tag>块级元素和内联元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html的基础回顾]]></title>
    <url>%2F2018%2F04%2F26%2Fhtml%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[头文件 &lt;!DOCTYPE&gt; 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。 文档段落 p标签是专门用来处理文档段落的。 pre标签即编辑器中是什么样的格式，那么网页中就是什么样的格式。 而p标签中自行输入的空格不起效果，若要换行则加入br标签。但是整体上仍然是一个段落。 align属性即对齐方式。 其中特别的是 justify： 对行进行伸展，这样每行都可以有相等的长度。 bgcolor属性即背景色。 b标签是文字加粗。 strong:粗体强调标签，强调，表示内容的重要性。 i标签和em标签都是文字斜体。 em:斜体强调标签，更强烈强调，表示内容的强调点。 sub标签是下标，sup标签是上标。 ins标签即插入内容，文字下带有下划线。通常和del标签共同使用。 del标签即删除线。 &amp;lt； &lt; 小于号或者显示标记。 &amp;gt； &gt; 大于号或者显示标记。 &amp;reg； &reg; 已注册符号。 &amp;trade；&trade; 商标符号。 &amp;nbsp； &nbsp; 不断行的空白。 &amp;copy； &copy; 版权符号。 hr 即水平线。单标签。noshade 列表标签 ul 无序列表。 默认开头为小黑圆点。 ol 有序列表。 默认开头为数字。 li 即列表中每项内容。 无序列表中， 属性type=disc即圆形。 属性type=square即正方形。 属性type=circle即空心圆。 有序列表中， 属性type=1 即默认数字开头。 属性type=a 即小写字母开头。 属性type=I 即罗马数字开头。 dl即定义列表。 dt即定义列表项。 dd即定义列表项的描述。 图片 绝对路径，即从盘符开始写出完整的地址。 相对路径 同级文件夹下的直接写文件名。 ../ 表示上一级。 ../../ 表示上一级的上一级。 下一级文件下的话即 文件夹/文件 绝对路径虽然说简单粗暴，但是若变动整个文件的位置，那就找不到了。 相反，相对路径无论整个文件夹在任何盘符变动，该文件夹下的文件与文件之间的关系是不变的。所以不影响。 图片无法显示时，可以用alt显示文字。 超链接 在a标签中写href 可以实现 空链接。 网站内部的锚跳转。 内部html文件的跳转。 外部网站的跳转。 默认情况下超链接都是在当前网页实现页面的跳转。 所以使用target属性 _self 即当前页面打开（默认）。 _blank 即创建一个新的窗口来打开新页面。 title 即链接提示文字。光标悬浮在链接上方时显示的文字。 a标签中，name属性 即链接名。 锚跳转的关键。 a标签中，href=”mailto:邮箱” 即邮箱链接。例如 1&lt;a href="mailto:niawenge@163.com"&gt;点击查看效果&lt;a/&gt; 文件下载 a标签中，href=”文件名” 即可下载文件。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>温故知新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多种下划线效果]]></title>
    <url>%2F2018%2F04%2F26%2F%E5%A4%9A%E7%A7%8D%E4%B8%8B%E5%88%92%E7%BA%BF%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[纯CSS实现的一些效果记录。 效果1效果：鼠标悬浮在内容上，下划线从左到右“展开”出现。鼠标挪开，下划线“缩回”左边。 12345678910111213141516171819div &#123; position: absolute; font-size: 100px; background: yellow;&#125;div::before &#123; content: ""; position: absolute; left: 0; bottom: 0; width: 0; height: 10px; background: deeppink; transition: width 1s;&#125;div:hover::before &#123; width: 100%;&#125; 原理：用before选择器“做出”下划线，定位在内容下方，且初始宽度设置为0。通过transition来改变宽度为100%从而实现动画效果。 效果2效果：鼠标悬浮在内容上，下划线从中心位置同时向左向右“展开”，鼠标离开则下划线两头“缩回”中心点。 123456789101112131415161718192021div &#123; position: absolute; font-size: 100px; background: yellow;&#125;div::before &#123; content: ""; position: absolute; left: 0; bottom: 0; height: 10px; background: deeppink; width: 100%; transition: transform 1s; transform: scaleX(0);&#125;div:hover::before &#123; transform: scaleX(1);&#125; 原理：设置宽度100%,然后利用transform: scale() 分别设置参数0和1实现线条运动。 效果3效果：鼠标悬浮在内容上的时候，下划线从左端出现，鼠标离开时，下划线从右边离开。即“左进右出”的假象。 12345678910111213141516171819202122div &#123; position: absolute; font-size: 100px; background: yellow;&#125;div::before &#123; content: ""; position: absolute; left: 0; bottom: 0; height: 10px; background: deeppink; width: 100%; transition: transform 1s; transform: scaleX(0); transform-origin: 100% 0;&#125;div:hover::before &#123; transform: scaleX(1); transform-origin: 0 0;&#125; 原理：其实同效果2只是增加了transform-origin，来更改一个元素变形（transform）的原点。即更改scaleX缩放的点。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>下划线特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从渲染机制理解并选择domReady]]></title>
    <url>%2F2018%2F04%2F24%2F%E4%BB%8E%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3%E5%B9%B6%E9%80%89%E6%8B%A9domReady%2F</url>
    <content type="text"><![CDATA[通过慕课网学习到了一个domReady的东西。很实用，记录下来。 问题由来因为浏览器解析 HTML 文档是从上到下、从左到右依次进行的，且JS可以改变DOM。所以，如果把 JS 放在 head 里的话，则先被解析，但这时候如果 body 还没有被解析，就会返回空值，也就是会出错。放在 head 中的 JS 代码会在页面加载完成之前就读取，而放在 body 中的 JS 代码，会在整个页面加载完成之后读取。 如果想把 JS 代码放在 head 部分中，还不想出错，怎么办？ 定时器首先提到了一个定时器的想法，指定时间让其加载。但是之前一篇文章提到JS的运行机制（同步和异步），具体来说是浏览器会把setTimeout认为是耗时操作。所以哪怕你把时间设置为0秒，任然有闪动的问题。 onload事件另一个想法是利用onload，但是这个方法在加载少量资源时还行，如果加载大量资源的话速度就明显慢了。毕竟onload 事件会在页面或图像加载完成后才立即发生。 domReady这也是本文重点。简单来说，和传统的onload的加载方式相比,这个办法更高效的地方就在于加载的时间点不同。最终才导致速度上的区别。 加载的时间点就得从渲染流程来说。 渲染流程渲染引擎渲染流程如下，这也通常被称作关键渲染路径（Critical Rendering Path）：1.构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）；2.构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树；3.执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）；4.构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)； DOMReady方法，是页面DOM树创建完成后（也就是HTML解析的第一步完场）就会触发，而无需等待其它资源的加载。 具体实现策略原生js实现domready实现策略1.支持domcontentload事件的，就使用DOMCONTENTLOAD事件2.不支持的，就用通过IE中的document.documentenlemt.doscroll(“left”)来判定DOM树是否创建完成 12345678910111213141516171819202122232425262728293031323334353637383940414243function myReady(fn)&#123; // 对于现代浏览器，对DOMContentLoaded事件的处理采用标准的事件绑定方式 if(document.addEventListener)&#123; document.addEventListener("DOMContentLoaded", fn, false); // 在冒泡阶段捕获 &#125; else &#123; IEContentLoaded(fn); &#125; // IE模拟DOMContentLoaded function IEContentLoaded(fn)&#123; var d = window.document; var done = false; // 只执行一次的用户回调函数init() var init = function()&#123; if(!done)&#123; done = true; fn(); &#125; &#125;; (function()&#123; try&#123; // DOM树未创建之前调用doScroll会抛出错误 d.documentElement.doScroll('left'); &#125; catch(e)&#123; // 延迟再试一次，调用函数自身的事件 setTimeout(arguments.callee, 50); return; &#125; // 没有错误就表示DOM树创建完毕，然后立马执行用户回调 init(); &#125;)(); // 监听document的加载状态 d.onreadystatechange = function()&#123; // 如果用户是在domReady之后绑定的函数，就立马执行 if(d.readyState == 'complete') &#123; d.onreadtstatechange = null; init(); &#125; &#125; &#125; &#125; // myReady(function ()&#123; // document.getElementById('main').style.color = 'red'; // &#125;);]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端</tag>
        <tag>domReady</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LHS查询和RHS查询]]></title>
    <url>%2F2018%2F04%2F23%2FLHS%E6%9F%A5%E8%AF%A2%E5%92%8CRHS%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[在看《你不知道的javascript》的时候，看到了两个以前不知道的东西————LHS和RHS 这其实是在讨论引擎，编译器，作用域三者关系的时候提到的。 1var a=2; 这里对于a就是用的LHS查询。即查找一个不在乎值是多少的变量容器。而RHS查询就不同了，目的就是在于查找所需要的值是多少。 1console.log(a); 这里需要打印出a的值，引擎就会像作用域询问a的值是多少。 还有一个作用域嵌套的基础知识。 即当前作用域查找不到所需要的东西时就会到上一级作用域继续查找。找到就做出相应的操作，找不到就继续向上级查找，直至到全局作用域。如果是RHS查询，直到全局作用域都查找不到的话，就会报错。引擎就会抛出 ReferenceError异常。而LHS查询在非严格模式下，在全局作用域中也查不到的话，会自动在全局作用域中创建一个变量，并且返回给引擎。 这也就解释了为什么有的变量没有声明却是全局变量了。 1234function foo(a)&#123; b = 1 ;//全局变量b&#125;foo(2); 书里还有这样一段话：如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，例如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError 。 这让我联想到之前也有遇到这个TypeError，就是在声明了一个变量，通过document取css中的id，然后赋值给这个变量，后续需要利用这个变量对css样式进行改变的时候，发现会报这个错误。后来才知道需要等css加载完才能取到这个id.（可以将js代码后置或者利用onload（）等方式解决）]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的this指向问题]]></title>
    <url>%2F2018%2F04%2F21%2Fjs%E7%9A%84this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这个this指向问题是目前我发现学JS比较难的一个知识块了。网上一些博客零零碎碎讲得都很片面，然后我特地查阅《你不知道的Javascript》才有了整体的理解。 书中详细地将几种情况做了区分： 默认绑定123456function foo() &#123;console.log( this.a );&#125;var a = "这是默认绑定测试";foo(); // 这是默认绑定测试 foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定 严格模式(特殊情况)123456function foo() &#123; "use strict"; console.log( this.a ); &#125;var a = 2;foo(); // TypeError: this is undefined 使用严格模式（ strict mode ），那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined 隐式绑定123456789101112function foo() &#123;console.log( this.a );&#125;var obj2 = &#123;a: "这是obj2的a",foo: foo //在一个对象内部包含一个指向函数的属性。并且通过这个属性可以间接引用函数&#125;;var obj1 = &#123;a: "这是obj1的a",obj2: obj2&#125;;obj1.obj2.foo(); // 这是obj2的a 隐式绑定是指通过为对象添加属性，该属性的值即为要调用的函数，进而使用该对象调用函数 隐式丢失问题当进行隐式绑定时，如果进行一次引用赋值或者传参操作，会造成this的丢失，使this绑定到全局对象中去。 引用赋值中的this丢失问题12345678910function thisTo()&#123; console.log(this.a);&#125;var data=&#123; a:2, foo:thisTo //通过属性引用this所在函数&#125;;var a=3;//全局属性var newData = data.foo; //这里进行了一次引用赋值newData(); // 3 愿意是通过隐式绑定得到data里的属性a的值，但是使用了引用赋值，this绑定到了全局对象中。 因为newData实际上引用的是foo函数本身，这就相当于：var newData = thisTo;而data对象只是一个中间桥梁，data.foo只起到传递函数的作用，所以newData跟data对象没有任何关系。而newData本身又不带a属性，不带任何修饰的函数调用，因此应用了默认绑定。最后a只能指向window。 传参操作中的this丢失问题12345678910111213function foo() &#123; console.log( this.a );&#125;function doFoo(fn) &#123; // fn 其实引用的是 foo fn(); // &lt;-- 调用位置！&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = "a 是全局对象的属性";doFoo( obj.foo ); // "a 是全局对象的属性" 123456789function thisTo()&#123; console.log(this.a);&#125;var data=&#123; a:2, foo:thisTo //通过属性引用this所在函数&#125;;var a=3;//全局属性setTimeout(data.foo,100);// 3 函数不管是传入自己定义的函数，还是语言内置的函数setTimeout中，同样，也会发生这个问题，this会被绑定到了全局对象中。同理：因为不管是doFoo还是setTimeout实际上引用的是foo函数本身，obj和data对象只是一个中间桥梁，obj.foo和data.foo只起到传递函数的作用。不带任何修饰的函数调用，因此应用了默认绑定。最后a只能指向window。 显示绑定显示绑定（不需要在一个对象内部包含函数引用。而是直接在某个对象上强制调用函数。）具体点说，可以使用函数的 call(..) 和apply(..) 方法。它们的第一个参数是一个对象，它们会把这个对象绑定到this ，接着在调用函数时指定这个 this 。即可以直接指定 this 的绑定对象。 1234567function foo() &#123;console.log( this.a );&#125;var obj = &#123;a:"这是显示绑定的测试"&#125;;foo.call( obj ); // 这是显示绑定的测试 如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String(..) 、 new Boolean(..) 或者new Number(..) ）。这通常被称为“装箱”。 但是任然无法解决丢失绑定的问题 硬绑定硬绑定可以解决丢失绑定的问题 call12345678910111213function foo() &#123;console.log( this.a );&#125;var obj = &#123;a:"这是硬绑定测试"&#125;;var bar = function() &#123;foo.call( obj );&#125;;bar(); // 这是硬绑定测试setTimeout( bar, 100 ); // 这是硬绑定测试// 硬绑定的 bar 不可能再修改它的 thisbar.call( window ); // 这是硬绑定测试 创建了函数 bar() ，并在它的内部手动调用了 foo.call(obj) ，因此强制把 foo 的 this 绑定到了 obj 。无论之后如何调用函数 bar ，它总会手动在 obj 上调用 foo 。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。这种办法可以解决丢失绑定的问题。 apply123456789101112function foo(something) &#123;console.log( this.a, something );return this.a + something;&#125;var obj = &#123;a:"1.这任然是"&#125;;var bar = function() &#123;return foo.apply( obj, arguments );&#125;;var b = bar( "硬绑定的测试" ); // 1.这任然是 硬绑定的测试console.log( b ); // 1.这任然是硬绑定的测试 在它的内部手动调用了 foo.apply( obj, arguments ) 辅助函数12345678910111213141516function foo(something) &#123;console.log( this.a, something );return this.a + something;&#125;// 简单的辅助绑定函数function bindtext(fn, obj) &#123;return function() &#123;return fn.apply( obj, arguments );&#125;;&#125;var obj = &#123;a:"2.这依然是"&#125;;var bar = bindtext( foo, obj );var b = bar( "硬绑定测试" ); // 2.这依然是 硬绑定测试console.log( b ); // 2.这依然是硬绑定测试 创建一个可以重复使用的辅助函数bindtext来实现硬绑定。其实本质上还是利用了apply。 内置的bind函数ES5 中提供了内置的方法 Function.prototype.bind 12345678910function foo(something) &#123;console.log( this.a, something );return this.a + something;&#125;var obj = &#123;a:"这是一个关于"&#125;;var bar = foo.bind( obj );//bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。var b = bar( "内置的bind函数的测试" ); // 这是一个关于 内置的bind函数的测试console.log( b ); // 这是一个关于内置的bind函数的测试 API调用的“上下文”123456789function foo(el) &#123;console.log( el, this.id );&#125;var obj = &#123;id: "awesome"&#125;;// 调用 foo(..) 时把 this 绑定到 obj[1, 2, 3].forEach( foo, obj );// 1 awesome 2 awesome 3 awesome 第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调函数使用指定的 this 。这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样可以少些一些代码。 new绑定12345function foo(something) &#123;this.a = something;&#125;var bar = new foo("new绑定测试");console.log( bar.a ); // new绑定测试 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建（或者说构造）一个全新的对象。 这个新对象会被执行 [[ 原型 ]] 连接。 这个新对象会绑定到函数调用的 this 。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 优先级可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断： 函数是否在 new 中调用（ new 绑定）？ 如果是的话 this 绑定的是新创建的对象。var bar = new foo() 函数是否通过 call 、 apply （显式绑定）或者硬绑定调用？如果是的话， this 绑定的是指定的对象。var bar = foo.call(obj2) 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话， this 绑定的是那个上下文对象。var bar = obj1.foo() 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined ，否则绑定到全局对象。var bar = foo() 规则之外的意外情况传入null12345function foo() &#123;console.log( this.a );&#125;var a = 2;foo.call( null ); // 2 如果把 null 或者 undefined 作为 this 的绑定对象传入 call 、 apply 或者 bind ，这些值在调用时会被忽略，实际应用的是默认绑定规则 12345678function foo(a,b) &#123;console.log( "a:" + a + ", b:" + b );&#125;// 把数组“展开”成参数foo.apply( null, [2, 3] ); // a:2, b:3// 使用 bind(..) 进行柯里化var bar = foo.bind( null, 2 );bar( 3 ); // a:2, b:3 如果某个函数确实使用了this （比如第三方库中的一个函数），那默认绑定规则会把 this 绑定到全局对象（在浏览器中这个对象是 window ），这将导致不可预计的后果（比如修改全局对象）。 DMZ空对象12345678910function foo(a,b) &#123;console.log( "a:" + a + ", b:" + b );&#125;// 我们的 DMZ 空对象var ø = Object.create( null );// 把数组展开成参数foo.apply( ø, [2, 3] ); // a:2, b:3// 使用 bind(..) 进行柯里化var bar = foo.bind( ø, 2 );bar( 3 ); // a:2, b:3 这是一种“更安全”的做法。传入一个特殊的对象，把 this 绑定到这个对象不会对程序产生任何副作用。就像网络（以及军队）一样，我们可以创建一个“DMZ”（demilitarizedzone，非军事区）对象——它就是一个空的非委托的对象使用变量名 ø 不仅让函数变得更加“安全”，而且可以提高代码的可读性，因为 ø 表示“我希望 this 是空”，这比 null 的含义更清楚。可以用任何喜欢的名字来命名 DMZ 对象。 间接引用12345678function foo() &#123;console.log( this.a );&#125;var a = 2;var o = &#123; a: 3, foo: foo &#125;;var p = &#123; a: 4 &#125;;o.foo(); // 3(p.foo = o.foo)(); // 2 软绑定硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this 。如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。可以通过一种被称为软绑定的方法来实现我们想要的效果： 12345678910111213141516if (!Function.prototype.softBind) &#123;Function.prototype.softBind = function(obj) &#123;var fn = this;// 捕获所有 curried 参数var curried = [].slice.call( arguments, 1 );var bound = function() &#123;return fn.apply((!this || this === (window || global)) ?obj : thiscurried.concat.apply( curried, arguments ));&#125;;bound.prototype = Object.create( fn.prototype );return bound;&#125;;&#125; 用 softBind 是否实现了软绑定功能： 1234567891011121314function foo() &#123;console.log("name: " + this.name);&#125;var obj = &#123; name: "obj" &#125;,obj2 = &#123; name: "obj2" &#125;,obj3 = &#123; name: "obj3" &#125;;var fooOBJ = foo.softBind( obj );fooOBJ(); // name: objobj2.foo = foo.softBind(obj);obj2.foo(); // name: obj2 &lt;---- 看！！！fooOBJ.call( obj3 ); // name: obj3 &lt;---- 看！setTimeout( obj2.foo, 10 );// name: obj &lt;---- 应用了软绑定 可以看到，软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上，但如果应用默认绑定，则会将 this 绑定到 obj 。 箭头函数箭头函数并不是使用 function 关键字定义的，而是使用被称为“胖箭头”的操作符 =&gt; 定义的。箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 this 。 12345678910111213141516function foo() &#123;// 返回一个箭头函数return (a) =&gt; &#123;//this 继承自 foo()console.log( this.a );&#125;;&#125;var obj1 = &#123;a:2&#125;;var obj2 = &#123;a:3100 ｜ 第 2 章&#125;;var bar = foo.call( obj1 );bar.call( obj2 ); // 2, 不是 3 ！ foo() 内部创建的箭头函数会捕获调用时 foo() 的 this 。由于 foo() 的 this 绑定到 obj1 ，bar （引用箭头函数）的 this 也会绑定到 obj1 ，箭头函数的绑定无法被修改。（ new 也不行！） 箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这其实和 ES6 之前代码中的 self = this 机制一样。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>前端</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http和https的通俗理解]]></title>
    <url>%2F2018%2F04%2F18%2Fhttp%E5%92%8Chttps%E7%9A%84%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[新闻前几天的一则新闻，内容大概是：谷歌宣布在2018年七月起，Chrome浏览器的地址栏将把所有http标识为不安全的网站。 其实过去几年里，谷歌一直在大力倡导网站采用https加密，让互联网变得更“安全”些。 经过了解，明白了其中的原因，当然也应该以通俗易懂的方式告诉没学过计算机的人。 首先，这个http并非没有加密，而是加密方式不安全假设A要给B发一个消息。A自己设置了一种方式，用盒子将消息装起来(加密处理)，且这个盒子需要特定的钥匙(密匙)才能打开。A给B发消息的话，想要安全发送必须用盒子包裹消息一起发送给B，但是考虑到B获取到盒子必须得打开才能读取到消息，那么A会把钥匙一起发送给B。每两人之间的通信都是不同的，用的不同的密匙，也就是说，如果有100个人，一个人至少要准备99把密匙。 这里还有一个安全问题，如果第三方C截取到钥匙，那这个加密处理就形同虚设了。 https相对安全的加密手段同样如果A要给B发一个消息A要传递的消息用盒子装起来，但是这次利用B准备的“盒子”和“钥匙”。这里说的“钥匙”即密匙，是专门放置在B这里用来做解密处理的，是保密的，只有B拥有。而这里说的“盒子”，即是A从B那里拿过来的公匙用来做加密处理的，是公开的。这样，A只要把用B的公匙进行加密处理，等价于收到B的空盒子并且把消息装进这个专属的盒子里，一起发送给B就可以了,这样也只有B才能解密。而对于第三方C，哪怕截取到盒子也无法打开获取里面的消息内容。所有人人手只要准备两把钥匙。 追根溯源其实https只是在http的基础上进行添加更改罢了。传输层增加了TLS协议。即是一种单向加密的方式（非对称加密）。 没有绝对安全，只有相对安全不能说用了https就是绝对安全的了。例如DH算法中也存在的安全隐患：（以下内容复制于百度百科） 没有提供双方身份的任何信息. 它是计算密集性的，因此容易遭受阻塞性攻击，即对手请求大量的密钥.受攻击者花费了相对多的计算资源来求解无用的幂系数而不是在做真正的工作. 没办法防止重演攻击. 容易遭受中间人的攻击.第三方C在和A通信时扮演B；和B通信时扮演A.A和B都与C协商了一个密钥，然后C就可以监听和传递通信量.中间人的攻击按如下进行： B在给A的报文中发送他的公开密钥. C截获并解析该报文.C将B的公开密钥保存下来并给A发送报文，该报文具有B的用户ID但使用C的公开密钥YC，仍按照好像是来自B的样子被发送出去.A收到C的报文后，将YC和B的用户ID存储在一块.类似地，C使用YC向B发送好像来自A的报文. B基于私有密钥XB和YC计算秘密密钥K1.A基于私有密钥XA和YC计算秘密密钥K2.C使用私有密钥XC和YB计算K1，并使用XC和YA计算K2. 从现在开始，C就可以转发A发给B的报文或转发B发给A的报文，在途中根据需要修改它们的密文.使得A和B都不知道他们在和C共享通信.]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>计算机网络</tag>
        <tag>信息安全技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的提升机制]]></title>
    <url>%2F2018%2F04%2F11%2FJavaScript%E7%9A%84%E6%8F%90%E5%8D%87%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[原本遇到的问题是函数声明和函数表达式中调用顺序的问题，后来查阅了相关资料又发现了个不得了的东西，就是JavaScript中的提升（hoisting）机制。 首先是这个函数声明和函数表达式。 函数声明： 12345//函数声明function text() &#123; return 1;&#125;cons 函数表达式： 12345678910111213141516//匿名的函数表达式var a = function() &#123; return 1; &#125; console.log(a());//1 //命名的函数表达式 var a = function text() &#123; return 1; &#125; console.log(a());//1 //自身调用的函数表达式 (function text() &#123; console.log(1);//1 &#125;)(); 函数声明和函数表达式表面上看上去是一样的，但是在调用的时候会出现问题。 123456console.log(typeof text());//numberconsole.log(text());//1function text() &#123; return 1;&#125;console.log(text());//1 上面的代码用的是函数声明，不管是在函数声明的定义之前或者之后调用，都是可以打印出正确的信息。 1234567console.log(a);//undefined// console.log(a());//如果这样打印的话这里会报错：TypeError: a is not a function var a = function text2() &#123; return 1; &#125; console.log(a);//会打印出整个text2函数。 console.log(a());//1 这里就很有意思了，在var a 之前打印a的话会返回undefined，打印a()则直接报错，不会继续打印后面的信息，注释掉后，可以发现之后调用，不管是打印a还是a()都能打印出正确的值。 知其然不知其所以然肯定是不行的。出现这种情况是为什么？ ps:网上有个一本正经的说法：用函数声明创建的函数可以在函数解析后调用（解析时进行等逻辑处理）；而用函数表达式创建的函数是在运行时进行赋值，且要等到表达式赋值完成后才能调用。 事实上，这是javascript的一个提升(hoisting)机制。 12345//先调用console.log(text());//1 function text() &#123; return 1; &#125; 提升后即： 12345//等价于函数被提升到调用之前 function text() &#123; return 1; &#125; console.log(text());//1 所以在函数声明里可以把调用写在前面。 而对于函数表达式： 1234console.log(a);//undefined var a = function text2() &#123; return 1; &#125; 提升后等价于： 12345var a ;console.log(a);//undefineda = function text2() &#123; return 1;&#125; 所以必须函数表达式必须先定义再调用。 同样的，变量也有提升，其实从函数表达式就能看出来。道理是一样的。在变量的作用域内，不管变量在何处声明，都会被提升到作用域的顶部，但是变量初始化的顺序不变。 123456789function text() &#123;var a; console.log(a);//undefined a = "3"; console.log(a);//3 a = "1"; console.log(a);//1&#125;text(); 第一个打印undefined,因为变量a只有声明没有赋值，然后打印3，是因为a被赋值3，最后打印1，是因为1覆盖了3存放在变量a中。 再回到网上这个一本正经的说法：用函数声明创建的函数可以在函数解析后调用（解析时进行等逻辑处理）；而用函数表达式创建的函数是在运行时进行赋值，且要等到表达式赋值完成后才能调用。 1234567891011121314151617181920var sayHello; 2 console.log(typeof (sayHey));//function 3 console.log(typeof (sayHo));//undefined 4 if (true) &#123; 5 function sayHey() &#123; 6 console.log("sayHey"); 7 &#125; 8 sayHello = function sayHo() &#123; 9 console.log("sayHello");10 &#125;11 &#125; else &#123;12 function sayHey() &#123;13 console.log("sayHey2");14 &#125;15 sayHello = function sayHo() &#123;16 console.log("sayHello2");17 &#125;18 &#125;19 sayHey();// sayHey220 sayHello();// sayHello 以上代码等价于： 12345678910111213141516171819202122var sayHello; 2 function sayHey() &#123; 3 console.log("sayHey"); 4 &#125; 5 function sayHey() &#123; 6 console.log("sayHey2"); 7 &#125; 8 console.log(typeof (sayHey));//=&gt;function 9 console.log(typeof (sayHo));//=&gt;undefined10 if (true) &#123;11 //hoisting...12 sayHello = function sayHo() &#123;13 console.log("sayHello");14 &#125;15 &#125; else &#123;16 //hoisting...17 sayHello = function sayHo() &#123;18 console.log("sayHello2");19 &#125;20 &#125;21 sayHey();// sayHey222 sayHello();// sayHello 综上所述：这个提升机制对于函数声明和函数表达式而言，其实关键就在于函数声明的提升(相当于整个定义被提升到前面)是解析后即可调用，而函数表达式是在变量赋值(运行时赋值)之后调用。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>函数声明和函数表达式</tag>
        <tag>hoisting 提升机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本包装类型的“短命”问题]]></title>
    <url>%2F2018%2F04%2F10%2FJavascript%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[首先得知道JS中分为两种类型：基本类型和引用类型。 基本类型：Undefined,Null,Boolean,Number,String 引用类型：Object,Array,Date,RegExp等，即对象。。。 学过面向对象的再学这个基本包装类型肯定会出现一点混乱，就是在JS中基本类型可以有自己的属性和方法了。。 基本类型中有三个比较特殊的存在就是：String Number Boolean，这三个基本类型都有自己对应的包装对象。并且随时等候召唤。而包装对象呢，其实就是对象，有相应的属性和方法。但是在后台偷偷发生的。 我觉得这三个特殊的包装对象虽然可以把它们当做对象来用，但是它们是实实在在的“短命鬼”（生命周期短）。网上也有很多讲解基本包装类型的，但是只是讲出了区别，并没有说该如何使用。然后我在思考的是它们既然是“短命”的，那该怎么用？只知道它们是基本包装类型是肯定不够的。 以下是测试代码： 123456789101112var s1 = "hello";s1.name = "Jack";console.log(s1.name);//undefinedconsole.log(s1.charAt(0));//hconsole.log(s1.indexOf('e'));//1var s2 ="hello2";String.prototype.shuchu_Jack=function()&#123; return s2+" "+(s2.name = "Jack");&#125;;console.log(s2.shuchu_Jack());//hello2 Jack 结果注释在代码中了，很明显如果将方法写在包装对象对应的原型下面的话，就可以完美解决“短命”问题了。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>基本包装类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 之 with]]></title>
    <url>%2F2018%2F04%2F09%2FJavaScript-%E4%B9%8B-with%2F</url>
    <content type="text"><![CDATA[看书的时候看到这个with蛮特别的，处了可以缩减代码量，还能延长作用领链。感觉很厉害，但是看了几个博客之后，发现这个东西能不用就不用吧。。。 特别是这个性能的问题极其夸张啊： 1234567891011121314151617181920212223242526272829303132333435363738394041function func() &#123; console.time("func"); var obj = &#123; a: [1, 2, 3] &#125;; for (var i = 0; i &lt; 1000000; i++) &#123; var v = obj.a[0]; &#125; console.timeEnd("func"); &#125; func();function funcWith1() &#123; console.time("funcWith1"); var obj = &#123; a: [1, 2, 3] &#125;; var obj2 = &#123; x: 2 &#125;; with (obj2) &#123; console.log(x); for (var i = 0; i &lt; 1000000; i++) &#123; var v = obj.a[0]; &#125; &#125; console.timeEnd("funcWith1"); &#125; funcWith1(); function funcWith2() &#123; console.time("funcWith2"); var obj = &#123; a: [1, 2, 3] &#125;; with (obj) &#123; for (var i = 0; i &lt; 1000000; i++) &#123; var v = a[0]; &#125; &#125; console.timeEnd("funcWith2"); &#125; funcWith2(); 借用以上代码测试分别在火狐和谷歌浏览器调试发现：js代码代码执行时间差距百倍不止。。。 下面几条来自 《javascript权威指南》 第 5 版本。 使用with的语句很难优化。 使用with语句速度要比不使用with语句的等价代码的速度慢得多。 在with语句中的函数定义和变量初始化可能产生令人惊讶，和直觉相抵触的行为。 90%(或者更高比例)的with应用场景都可以用其他更好的方式代替。 而且严格模式下，使用with语句将报错。因为with语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。 有了 With 语句，在存取对象属性和方法时就不用重复指定参考对象但是除了稍微缩减了代码让其看起来可以更简洁一点，你还有别的更好的应用场景吗？那你设计这个语法的意义？？？]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>with</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记一：能用HTML/CSS解决的问题就不要用JS]]></title>
    <url>%2F2018%2F04%2F07%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[近期在阅读李银城老师的新书《高效前端 web高效编程与优化实践》 导航高亮直接上代码 以下是html 123456789101112&lt;body class="home"&gt; &lt;nav&gt; &lt;li class="home"&gt;home&lt;/li&gt; &lt;li class="buy"&gt;buy&lt;/li&gt; &lt;/nav&gt;&lt;/body&gt;&lt;body class="buy"&gt; &lt;nav&gt; &lt;li class="home"&gt;home1&lt;/li&gt; &lt;li class="buy"&gt;buy1&lt;/li&gt; &lt;/nav&gt;&lt;/body&gt; 以下是css 1234567nav li&#123; opacity: 0.5;&#125;nav li:hover&#123; opacity: 1;&#125;body.home nav li.home,body.buy nav li.buy&#123; opacity: 1;&#125; 如果当前页面是home，则home高亮。 如果用js控制。那么在脚本加载好之前不会高亮，脚本加载好之后会突然高亮。 对于hover，如果用js的mousse事件实现功能，会在mouseover和mouseleave的时候添加和删除一个类，即复杂了。 鼠标悬浮显示书上的做法都尝试过后，还是下面这种方法最简单高效。同样直接上代码 html 123456789&lt;div class="father"&gt; &lt;li class="user"&gt;用户&lt;/li&gt; &lt;li class="menu"&gt; &lt;ul&gt; &lt;li&gt;账户设置&lt;/li&gt; &lt;li&gt;登出&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/div&gt; css 1234.father .menu&#123; display:none;&#125;.father:hover .menu&#123; display:list-item;&#125; 使用子元素，这个更简单。把hover的目标和隐藏的对象当作同一个父容器的子元素(我这边是用DIV把.user和.menu包裹起来)，然后hover写在这个父容器上面就可以了，不用像其他方法，隐藏元素也要写个hover： ps:相邻选择器和伪类选择器的用法还需要回顾一下。 自定义radio/checkbox的样式二话不说直接上代码 123456789101112131415161718192021&lt;style&gt; input[type=checkbox]&#123; display:none; &#125;/*未选中的checkbox的样式*/ .checkbox&#123; font-size: 50px； &#125; input[type=checkbox]:checked + .checkbox&#123; font-size: 100px; &#125; label&#123; display: inline-block; width: 400px; height: 200px; background: gray; &#125; &lt;/style&gt; &lt;label&gt; &lt;input type="checkbox"&gt; &lt;span class="checkbox"&gt;你好&lt;/span&gt; &lt;/label&gt; 以上代码的功能：一个灰色的矩形框里面有100px大小的“你好”。点击灰色矩形框任何区域，能够缩小“你好”的字体大小为50px。 关键操作： 把一个checkbox和一个用来自定义样式的span写在一个label里面，checkbox始终隐藏。 写在label里面是为了能够点击span的时候改变checkbox的状态，然后再改一下选中态的样式即可。 核心想法：这主要借助了CSS3提供的一个伪类:checkd，只要radio/checkbox是选中状态，这个伪类就会生效，因此可以利用选中和非选中的这两种状态，去切换不同的样式。 :checked兼容性很不错。收纳！ 多列等高多列等高问题：排成一行的几列由于内容长短不一致，导致容器的高度不一致。 解决方式： 用js算一下，以最高的一列的高度去设置所有列的高度.结果：会造成页面闪动，即刚开始打开页面的时候高度不一致，然后发现突然又对齐了。（方法不行） 每列来一个很大的padding，再来一个很大的负的margin值矫正回去。结果：虽然对齐是对齐了，但是底部的border没有了，设置的圆角也不起作用了，究其原因，是因为设置了一个很大的padding值，导致它的高度变得很大，而且如果你想在底部absolute定位放一个链接”更多&gt;&gt;”也是实现不了了。（方法不行） 借助table的自适应特性 ，每个div都是一个td，td肯定是等高的。（优秀） html 123456&lt;div class="wrapper"&gt; &lt;div class="n"&gt;column 11111111111111111 11111111111111 111111111111111111 11111111111111111 11111111111&lt;/div&gt; &lt;div class="n"&gt;column 11111111111111111 11111111111111 111111111111111111 11111111&lt;/div&gt; &lt;div class="n"&gt;column 11111111111111111 11111111111111 111111111111111111 &lt;/div&gt; &lt;div class="n"&gt;column 11111111111111111 11111111111111 &lt;/div&gt;&lt;/div&gt; css 12345678910 .wrapper&#123; display:table; border-spacing:20px; /* td间的间距*/ &#125;.wrapper &gt; div &#123; display:table-cell; width:100px; /*设置大一点的宽度，table自动平分宽度 */ border-radius:5px; /*这里设置圆角就正常了*/ background: pink; &#125; 不仅能实现等高等宽，而且响应式开发的时候，可以借助媒体查询动态地改变display的属性，从而改它排列的方式。（优秀） 修改CSS 1234567891011121314151617181920212223 .wrapper&#123; display:table; border-spacing:20px; /* td间的间距*/ &#125;.wrapper &gt; div &#123; display:table-cell; width:200px; /*设置大一点的宽度，table自动平分宽度 */ border-radius:5px; /*这里设置圆角就正常了*/ background: pink; &#125; @media (max-width: 1000px)&#123; .wrapper&#123; display:block; border-spacing:20px; &#125; .wrapper &gt; div &#123; display:block; height:200px; border-radius:5px; background: pink; &#125; &#125; 补充：如果在pad 1024px的设备上，希望一行显示2个，那应该怎么办呢？由于上面用的td，必定会排在同一行。其实可以在第二个和第三个中间加一个tr，让它换行： 1234567&lt;div class="wrapper"&gt; &lt;div&gt;column 1&lt;/div&gt; &lt;div&gt;column 2&lt;/div&gt; &lt;span class="tr"&gt;&lt;/span&gt; &lt;div&gt;column 3&lt;/div&gt; &lt;div&gt;column 4&lt;/div&gt;&lt;/div&gt; 在大屏和小屏时，tr是不显示的，而在中屏时，tr显示： 123456789.tr&#123; display:none;&#125;@media (max-width: 1024px) and (min-width: 501px)&#123; .tr&#123; display:table-row; &#125;&#125; 这样就能够实现在小屏时一行排两列了，只是这个有个小问题，就是在中屏拉到大屏的时候tr的dipslay: none已经没有什么作用，因为table的布局已经计算好。但是一般应该不用考虑这种拉伸范围很大的情况，正常刷新页面是可以的，如果真要解决那得借助下js。]]></content>
      <categories>
        <category>HTML/CSS性能优化</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>前端</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域问题]]></title>
    <url>%2F2018%2F04%2F06%2F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[那天美图秀秀实习生笔试中遇到的几个题让我印象深刻。其中一个是问跨域的解决方式有哪些？模模糊糊的写不出来真的是比较尴尬。真是书到用时方恨少,事因经过始知难啊。后来整理了一下，记录下来。 跨域的定义在网上看了好几个版本对于跨域的定义。大同小异。记：只要协议、域名、端口有任何一个不同，都被当作是不同的域。 1.1域名例如mail.cctv.com其中com是顶级域名，cctv是二级域名，mail是三级域名。 1.2跨域实例 域名比较 理由 是否允许访问 http://www.a.com/a.js http://www.a.com/b.js 同一域名下 允许 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名，不同端口 不允许 http://www.a.com/a.js https://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.js http://70.30.92.74/b.js 域名和域名对应ip 不允许 http://www.a.com/a.js http://script.a.com/b.js 主域相同，子域不同 不允许 http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名（同上） 不允许 http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 不允许 同源策略同源策略： 不同的域名, 不同端口, 不同的协议不允许共享资源的， 保障浏览器安全。 2.1. 同源策略限制范围 Cookie、LocalStorage 和 IndexDB 无法读取。 DOM 无法获得。 AJAX 请求不能发送。 例如，Cookie中保存的用户名、密码等个人敏感信息通常经过加密，很难将其反向破解。但这并不意味着绝对安全，黑客可通过木马病毒盗取用户浏览器Cookie，直接通过偷取的Cookie骗取网站信任。 2.2.同源策略相关知识点了解通过查阅资料get到相关的知识点也可以了解一下： 跨站脚本攻击(Cross Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。 CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。 document.domain文档中给出的定义和用法:domain 属性可返回下载当前文档的服务器域名。 未完待续。。。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的机制以及进程与线程之间的关系]]></title>
    <url>%2F2018%2F04%2F05%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[对于进程和线程正儿八经的官方解释：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程） 然后知识点来了：1.浏览器是多进程的！每打开一个Tab页，就相当于创建了一个独立的浏览器进程(如果看到有些进程被合并了是因为浏览器有自己的优化机制)。2.为什么使用多进程架构？早期的时候，一个进程处理多个网页时可行的。但是时至今日，网页越来越复杂，必须从一个网页的健壮性，响应速度，安全性方面来考虑的。特别是这个安全性：采用多进程，即使是浏览器其中的一个进程出现了崩溃现象(比如第三方插件进程崩溃了，也不会影响整个浏览器)，其他的进程也不会受到影响！相对于线程，进程之间是不共享资源和地址空间的,所以不会存在太多的安全问题！而多个线程共享着相同的地址空间和资源,所以会存在线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题！ 当然了，在操作系统课中提及N次的一个“空间换时间”的说法这边也是管用的。采用多进程的话，内存等资源消耗也会更大。 接着再了解一下浏览器的内核：浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。例如：GUI 渲染线程，JavaScript引擎线程，定时触发器线程，事件触发线程，异步http请求线程等。 1.为什么说GUI渲染线程与JS引擎线程互斥？由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。所以，浏览器必须设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。 2.JS阻塞页面加载？因为在互斥的前提下，如果js执行时间过长,GUI就会一直等待。(网页卡的一个重要原因！) 3.如何解决JS耗时操作的问题？在HTML5中支持了Web Worker！！！简单点说就是 通过创建Worker(子线程),浏览器给JS开了一条vip通道，完全受JS主线程控制，但是不能操作DOM！！工作完再把数据回传给JS。渲染的同时又可以进行大计算量的工作的作用，即这是一个可以专门用来解决那些大量计算问题线程。值得一提的是：JS引擎仍然是单线程的！Worker诞生于浏览器但是隶属于JS罢了。JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据） 4.SharedWorker？如果同时加载多个标签页，那么如果使用普通的worker我们可能会重复创造多个线程 这必然会占用系统资源。为了解决这个问题诞生了这个共享线程SharedWorker。浏览器为SharedWorker单独创建一个进程来运行程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。即本质上SharedWorker是由独立的进程管理，而WebWorker只是属于render进程下的一个线程。 浏览器器内核拿到内容后，渲染，接着是load事件了(先DOMContentLoaded ，后load)，之后就是自己的JS逻辑处理了。 JS的运行机制： 有必要说一下JS里的同步和异步：首先，javascript语言是一门“单线程”的语言！！！通俗的说，食堂打饭的时候必须排队，前面一个人打完饭菜才轮到下一个人。但是如果遇到前面的人在付钱的时候找饭卡或者发现饭卡没钱得充钱再付款类似这样的浪费时间的行为，肯定不可能所有人等他。所以对于类似这种浪费时间的行为。可以开辟另一个通道，先让这些饭卡准备好的不浪费时间的同学先打饭，之后再让“特殊通道”的同学打饭。对应的，(在执行栈中)正常排队打饭的同学即主线程的同步任务(不耗时)。特殊通道(任务队列)排队等待打饭的同学就是异步任务(耗时)。 附上一段js代码。 console.log( “1” ); setTimeout(function() { console.log( “2” ) }, 0 ); setTimeout(function() { console.log( “3” ) }, 0 ); setTimeout(function() { console.log( “4” ) }, 0 ); setTimeout(function() { console.log( “5” ) }, 0 ); console.log( “6” ); 程序的输出顺序是 1 6 2 3 4 5 显而易见的是，虽然设置了setTimeout（function，time）中的等待时间为0，结果其中的function还是后执行。这是因为浏览器会默认setTimeout以及ajax请求这一类的方法都是耗时程序（尽管可能不耗时），将其加入一个队列中，该队列是一个存储耗时程序的队列，在所有不耗时程序执行过后，再来依次执行该队列中的程序。PS:W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 另外。setTimeout后，是如何等待特定时间后才添加到事件队列中的？它是由定时器线程控制(JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确)。当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。 (setTimeout和setInterval仍需学习总结) (macrotask与microtask仍需学习总结)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>知识梳理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS基础回顾1]]></title>
    <url>%2F2018%2F04%2F05%2FCSS%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE1%2F</url>
    <content type="text"><![CDATA[复习盒子标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin低版本IE盒子模型：宽度=内容宽度（content+border+padding）+ margin CSS选择器id选择器(#idname)类选择器(.classname)标签选择器(div, h1, p)群主选择器(多个标签或元素用,隔开)相邻选择器(h1 + p)子选择器（ul &gt; li）后代选择器（li a，即用空格隔开）通配符选择器（*）属性选择器（a[rel=”external”]）伪类选择器（a:hover, li:nth-child）链接伪类的四种状态:(状态顺序不能变) :link 未访问的链接。 :visit 已经访问的链接。 :hover 鼠标悬浮在链接上方时。 :active 点击链接但是还未松开的状态。 其中，hover和active两种伪类不仅仅适用于a标签，也可以用于其他的元素。 不可继承的样式border, padding, margin, width, height 选择器的优先级所谓的优先级，指的是CSS样式在浏览器中被解析的先后顺序。通常情况下。优先级情况为：ID选择器&gt;class选择器&gt;标签选择器。 如果权值相同，则选择最后出现的样式，即就近原则。否则权值高优先级高，这时与顺序无关。 权值根据权值来判断优先级情况： 继承得到的样式的优先级最低。 通配符选择器：0； 元素选择符： 1； 类选择器和伪类选择器： 10； id选择器：100； 行内样式：1000； !important声明的样式优先级最高，如果冲突再进行计算。 权值计算规则 统计不同选择器的个数 每类选择器的个数乘以相应的权值 把所有的值相加得出选择器的权值 displayinline（默认）–内联none–隐藏block–块显示table–表格显示list-item–项目列表inline-block 兼容性问题不同浏览器的标签默认的margin和padding不一样。 *{margin:0;padding:0;} IE6双边距bug：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。hack：display:inline;将其转化为行内属性。 渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“9”这一标记，将IE浏览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 { background-color:#f1ee18;/*所有识别*/ .background-color:#00deff\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/ } 设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。 IE下，可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了。解决方法是改变CSS属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {} 为什么要初始化CSS样式因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。浮动带来的问题： 父元素的高度无法被撑开，影响与父元素同级的元素 与浮动元素同级的非浮动元素（内联元素）会跟随其后 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。 清除浮动的方式： 父级div定义height 最后一个浮动元素后加空div标签 并添加样式clear:both。 包含浮动元素的父标签添加样式overflow为hidden或auto。 父级div定义zoom]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你能做到不睡觉吗？]]></title>
    <url>%2F2018%2F04%2F04%2F%E4%BD%A0%E8%83%BD%E5%81%9A%E5%88%B0%E4%B8%8D%E7%9D%A1%E8%A7%89%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[如题，你能做到不睡觉吗？ 海豚不睡觉的秘密马呢，通常睡3个小时就够了，长颈鹿每天只需睡2个小时，大象只睡4个至5个小时。睡眠对于动物而言意义重大。哪怕是机器也要有更新换代的时候。 然而有意思的是海豚，它们正常情况下左右脑都是清醒的，而睡觉的时候它们只用一半大脑睡觉。如果它们进入深睡阶段，一半大脑就关闭了，另一半大脑则操纵身体的游动。它们一只眼睛闭上，另一只眼睛睁开，侧着身子兜圈子，经常浮出水面呼吸。过了一段时间后它们就转身，闭上另一只眼睛，用另一半大脑睡觉，从而来回交替。 人类甚至通过借鉴这个特殊的方式发明了蓝绿部署(Blue Green Deployment)！ 蓝绿部署简单来说就是两个一样的服务并行地存在(左右脑)，当需要更新换代的时候(睡觉)，让其中一个服务先升级，用另一个去服务。升级完再换班升级，从而两个服务都得到升级，最终一起服务。从宏观的角度来看就是没有停止过对外服务的。 除此之外还有什么滚动部署，金丝雀部署等。 金丝雀部署值得一提的是这个金丝雀部署，其实也来自对动物的观察，“金丝雀”的由来：17世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；而当瓦斯含量超过一定限度时，虽然鲁钝的人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为“瓦斯检测指标”，以便在危险状况下紧急撤离。简单理解就是抓一只”金丝雀”来测试是否安全，从而考虑是否继续下一步的部署工作。 脑洞时间通过对部署方式的了解，因此引发的一个比较小的联想是：如果人类可以做到用左右脑交替休息但是不停止工作的方式生存的话，人类文明可能已经进步到无法想象的地步了吧。接着，再继续延伸，不断地微观去考虑，如果我更换的是一个器官呢？有人可能会说这样会出现记忆错乱，一个身体拥有两份记忆，甚至长时间因为记忆影响生活。那么没关系，如果每次我只替换一个或者几个细胞呢？这样肯定对我的身体没有大影响吧？并且当我身体的细胞都逐渐地更替的过程中，少量的细胞肯定会慢慢填充我个人的记忆并且适应我最终为我所用。最终人类可以永生和永葆青春。 LAST当然了，脑洞终究是脑洞，之前新闻提及的换脑技术还是个人类难题。活在当下，我觉得目前能做到的且切合实际的就是做事要有两手准备。突发情况发生，一副运筹帷幄的样子一边挥一挥孔明扇：“plan A失败了，我还有plan B!!!”]]></content>
      <categories>
        <category>脑洞</category>
      </categories>
      <tags>
        <tag>脑洞</tag>
        <tag>蓝绿部署</tag>
        <tag>海豚</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黎明前的黑暗]]></title>
    <url>%2F2018%2F04%2F03%2F%E9%BB%8E%E6%98%8E%E5%89%8D%E7%9A%84%E9%BB%91%E6%9A%97%2F</url>
    <content type="text"><![CDATA[观看了逻辑思维近两年的跨年演讲，针对演讲中提出的五只黑天鹅和六个脑洞，并且结合操作系统的知识和理解，对于人工智能阐述出自己的一些看法和想法。 人和人工智能的对比先谈谈人类不如人工智能的地方。正如万维钢老师说的：“以有限的时间除以无限的信息，结果是零。”互联网的疯狂发展，出现了一大堆的有价值的信息和垃圾信息，它们之间相互交错，对于人类而言，繁杂的信息在有限的时间是无法完全获取的。在操作系统中，面对大量的资源同时涌入的时候，会采取互斥的想法去避免死锁的发生，正如多个方向的车辆同时需要进入唯一一个停车场的时候，采用一定的方式选择车辆并且有秩序地让车辆一辆一辆进入，避免车辆堵在门口等待释放空间准备进入。 而对于人工智能，可能在所谓的“停车场”中开辟多个出口入口，实时且并行的输入输出，从而来加快速度并且不会发生阻塞问题。同时，哪怕是人工智能技术，在目前为止也必须对访问磁盘有一定的要求，在操作系统中，对磁盘的访问要求来自多方面，常常需要排队。这时，对众多的访问要求按一定的次序响应，会直接影响磁盘的工作效率，进而影响系统的性能，后来衍生出了诸多的算法去解决问题。并且我认为伴随的云存储的发展，它对于信息的接收能力更加强大。更何况5G网络时代也即将进入人类的生活，一秒下载一部电影的速度也拥有了，数据的在网络的上传下载更加迅速。我猜想未来人工智能发展到一定水平，不一定是依附于硬件生存的，或许能够将本身作为一串二进制数据存活在网络中，随时可以出现，难以捕获也难以杀死。 接着演讲中提到一个奥卡姆剃刀原则，叫如无必要，勿增实体。每个人的生命有限，一个人一天只有24小时的时间，作为生命体又必须为了生存而花费一部分时间，剩下的时间用于学习，娱乐，工作等等。这又和机器有很大的区别。机器除非硬件的损坏老化，在能源充足的情况下能够不停的运行。李世石大战AlphaGO，人类和人工智能机器人之间的围棋博弈已经证明了这一点，人工智能机器人能够在一个晚上下足一百万盘围棋去进行深度学习，从而提升自己的胜率，这是人类花一辈子也应该达不到的水平。 再者说，以当今时代的中国，规模化绝对是优势之一。相同的，如果人工智能技术发展起来以后，它也能够以一定的规模化逐步在世界上占有一席之地，并且是逐步取代大量的人类工作。比如工厂中的工人通常都是日复一日的做简单且枯燥无味的机械运动，而且人是有惰性的，身体不好还容易生病，那么人工智能机器人取代人类的这种特定技能的工作岗位进行大规模的作业也指日可待的。在思维方式和精力以及学习能力上，这又是人类和人工智能的差距。 再与之无法匹敌的就是“记忆”能力，人工智能机器人可以在短期内迅速地将信息存储到存储区中，而人类苦于用各种各样的记忆方式去想办法快速记住信息的时候，又输了一筹。一个具有资深经验的医生在判定某女子无药可治的时候，人工智能机器人仅仅花了十几分钟就阅读了成千上万的医学文献，然后给出医学建议最终将她拉回死亡的边缘。这点上又打败了人类。而人类所能做的就是通过一些技术对自己的大脑进行“延伸”，正如电脑其实就是类大脑的一种发明，大量的信息没办法全部一一记下，那么就通过硬盘存放，而电脑中的主存也有一定的实际存储空间，从一开始的单道环境到多道环境的存储管理，不管是静态还是动态的方式，通过移动或者覆盖技术，哪怕是后来真正意义上从逻辑扩充主存容量的虚拟存储器的概念的引入，都其实是人类的“延伸”。 脑洞时间正是有因为这些差距，我觉得人工智能是一个具有两面性的东西。先谈谈有利角度，比特化脑洞告诉我们：无论世界如何数字化，两个趋势都不变：一个是效率越来越高，一个是分工越来越细致。未来人工智能会大批量投入现时生活也指日可待，人工智能技术在成熟之后在某一个专业领域能有更加高效的成果。所以应该在各个专业领域都有各自专属的的人工智能机器人为人类服务。它们彼此之间分工明确且协调合作。让人类的生活节奏指数倍加快，至少在人工智能发展的前中期是绝对有利于人类的发展的，甚至对于人类而言能够达到一个前所未有的新高度。 再说说我认为人工智能有害的角度，第一种想法源于人性的思考。正如拔河脑洞：拔河游戏不关心什么是你的什么是我的，只关心价值的移动方向。就目前而言，全球都在抢先争夺人工智能技术的制高点，就当今世界而言，早已经不是毛泽东的人多力量大就能决定最终胜利的时代，时代已经在改变，韩国和美国存储芯片的垄断已经对其它国家产生了极大的影响，就2017年至2018年的年初，内存条的价格仍然居高不下。吃鸡游戏玩家又不得不为追求游戏体验感而忍痛购买内存条。商人的世界就是只要技术在手，就敢漫天要价。人性本善还是本其实谁都说不清，但是世界总是平衡的，善恶一定是共存的，人工智能的发展被惟利是图的人所利用的话，小范围来说可能是骗钱手段，大范围来说这极有可能被运用于人类之间的战争。 然后第二种想法源于罗胖对于目前人工智能定义，他将人工智能为一个比人类更加聪明，比人类更加勤奋，非常听话的小孩子。然而回想起看过的僵尸题材的系列电影《生化危机》，我有一个想法，如果人工智能发展到一定水平的时候且它一开始是被设置为保护环境，清除破坏环境的垃圾为终极目标，这样看好像有利于人类，但是细思极恐，如果部分人类乱扔垃圾，吸烟等等破坏环境的行为出现，那么这部分人类是否会被人工智能机器人标记为“垃圾”呢？简单来说，人工智能机器人在经过大数据分析以及深度学习之后，必定会采取高效的措施来整治环境，那么它绝不会跟在这些人身后收拾烂摊子做吃力不讨好的工作，所以人类非常有可能被人工智能所杀死。 第三种想法就源于类似《黑客帝国》这样的科幻电影，如果人工智能的发展已经直接衍生出新物种的存在或者说所有人类被一台巨型“大脑”所控制。那么人类是否会成为优胜劣汰的生存空间中的牺牲品呢？对于枢纽脑洞：《枪炮病菌与钢铁》的作者戴蒙德说：“历史上的国家和社会衰败，更多只是影响到自己。而今天任何一个国家的衰落，都可能影响到世界上其他地方。”这句话其实和短板效应的意思是类似的。但是如果人工智能统治全世界只剩一个国家的话，情况就截然不同了。 总结逆水行舟，不进则退。没有前人的经历就只能以身犯险去踏出这一步。相信人类能够控制好自己的产品，会迎来明媚的曙光。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>脑洞</tag>
        <tag>人工智能</tag>
        <tag>操作系统</tag>
        <tag>逻辑思维</tag>
      </tags>
  </entry>
</search>
